var documenterSearchIndex = {"docs":
[{"location":"examples/stadium/#Driving-in-a-Stadium-1","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"","category":"section"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"This example demonstrates a 2D driving simulation where cars drive around a three-lane stadium. The entities are defined by the types:","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"S - VehicleState, containing the vehicle position (both globally and relative to the lane) and speed \nD - VehicleDef, containing length, width, and class\nI - Symbol, a unique label for each vehicle","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"The environment is represented by a Roadway object which  allows to define roads consisting of multiple lanes based on the RNDF format.","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"We load relevant modules and generate a 3-lane stadium roadway:","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"using AutomotiveDrivingModels\nusing AutoViz\nAutoViz.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Distributions\n\nroadway = gen_stadium_roadway(3)\nsnapshot = render([roadway])\nwrite(\"stadium.svg\", snapshot) # hide","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"(Image: three lane stadium)","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"As a next step, let's populate a scene with vehicles","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"w = DEFAULT_LANE_WIDTH\nscene = Frame([\n    Entity(VehicleState(VecSE2(10.0,  -w, 0.0), roadway, 29.0), VehicleDef(), :alice),\n    Entity(VehicleState(VecSE2(40.0, 0.0, 0.0), roadway, 22.0), VehicleDef(), :bob),\n    Entity(VehicleState(VecSE2(30.0, -2w, 0.0), roadway, 27.0), VehicleDef(), :charlie),\n])\ncar_colors = get_pastel_car_colors(scene)\nrenderables = [\n    roadway,\n    (FancyCar(car=veh, color=car_colors[veh.id]) for veh in scene)...\n]\nsnapshot = render(renderables)\nwrite(\"stadium_with_cars.svg\", snapshot) # hide","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"(Image: stadium with cars)","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"We can assign driver models to each agent and simulate the scenario.","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"timestep = 0.1\nnticks = 300\n\nmodels = Dict{Symbol, DriverModel}(\n    :alice => LatLonSeparableDriver( # produces LatLonAccels\n        ProportionalLaneTracker(), # lateral model\n        IntelligentDriverModel(), # longitudinal model\n    ),\n    # :bob => Tim2DDriver(\n    #     timestep, mlane = MOBIL(timestep),\n    # ),\n    :bob => StaticDriver{AccelTurnrate, MvNormal}(\n        MvNormal([0.0,0.0], [1.0,0.1])\n    ),\n    :charlie => StaticDriver{AccelTurnrate, MvNormal}(\n        MvNormal([0.0,0.0], [1.0,0.1])\n    )\n)\n\nset_desired_speed!(models[:alice],   12.0)\nset_desired_speed!(models[:bob],     10.0)\nset_desired_speed!(models[:charlie],  8.0)\n\nscenes = simulate(scene, roadway, models, nticks, timestep)\nnothing # hide","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"An animation of the simulation can be rendered using the Reel package","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"using Reel\nusing Printf\n\ncamera = TargetFollowCamera(:alice; zoom=10.)\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    update_camera!(camera, scenes[i])\n    renderables = [\n        roadway,\n        (FancyCar(car=veh, color=car_colors[veh.id]) for veh in scenes[i])...,\n        RenderableOverlay(IDOverlay(x_off=-2, y_off=1), scenes[i], roadway),\n        TextOverlay(text=[@sprintf(\"time: %.1fs\", t)], pos=VecE2(40,40), font_size=24)\n    ]\n    render(renderables, camera=camera)\nend\n\nwrite(\"animated_stadium.gif\", animation) # hide","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"(Image: animated stadium with cars)","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"Alternatively, one can also use the Interact framework to inspect the simulation record interactively.","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"using Interact\nusing Reel\nusing Blink\n\nw = Window()\nviz = @manipulate for step in 1 : length(scenes)\n    render([roadway, scenes[step]])\nend\nbody!(w, viz)","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"The simulation results can be saved to a text file. We achieve this by first converting the list of scene to a Trajdata type and then exporting it.","category":"page"},{"location":"examples/stadium/#TODO:-fix-writing-of-Trajdata-1","page":"Driving in a Stadium","title":"TODO: fix writing of Trajdata","text":"","category":"section"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"open(\"2Dstadium_listrec.txt\", \"w\") do io\n    @warn \"TODO: need to fix bug in write(trajdata)\"\n    # write(io, MIME\"text/plain\"(), Trajdata(scenes, timestep))\nend","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"The trajectory data file can be loaded in a similar way.","category":"page"},{"location":"examples/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"# listrec = open(\"2Dstadium_listrec.txt\", \"r\") do io\n#     @warn \"TODO: need to fix bug in write(trajdata)\"\n#     read(io, MIME\"text/plain\"(), Trajdata)\n# end\n\n# p = plot(listrec)\n# TODO: maybe do something useful with the loaded data, like plot the speed over time or something\n# write(p) # hide","category":"page"},{"location":"feature_extraction/#Feature-Extraction-[WIP]-1","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"AutomotiveDrivingModels.jl implements a feature extraction pipeline to extract information from pre-recorded simulation  in a QueueRecord or ListRecord. (see Records.jl for info on the data structure)","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"PRs for documenting feature extraction are more than welcome","category":"page"},{"location":"feature_extraction/#Neighbors-Features-1","page":"Feature Extraction [WIP]","title":"Neighbors Features","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"Here is a list of function to retrieve information about the neighbors of a given vehicle. ","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"    NeighborLongitudinalResult\n    get_neighbor_fore_along_lane\n    get_neighbor_fore_along_left_lane\n    get_neighbor_fore_along_right_lane\n    get_neighbor_rear_along_lane\n    get_neighbor_rear_along_left_lane\n    get_neighbor_rear_along_right_lane\n    FrenetRelativePosition\n    get_frenet_relative_position","category":"page"},{"location":"feature_extraction/#AutomotiveDrivingModels.NeighborLongitudinalResult","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.NeighborLongitudinalResult","text":"NeighborLongitudinalResult\n\nA structure to retrieve information about a neihbor in the longitudinal direction i.e. rear and front neighbors on the same lane. If the neighbor index is equal to nothing it means there is no neighbor.\n\nFields\n\nind::Union{Nothing, Int64} index of the neighbor in the scene\nΔs::Float64 positive distance along the lane between vehicles positions\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#AutomotiveDrivingModels.get_neighbor_fore_along_lane","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.get_neighbor_fore_along_lane","text":"get_neighbor_fore_along_lane(scene::EntityFrame{S,D,I}, roadway::Roadway, tag_start::LaneTag, s_base::Float64, targetpoint_primary::VehicleTargetPoint, targetpoint_valid::VehicleTargetPoint;\n                             max_distance_fore::Float64 = 250.0, index_to_ignore::Int=-1) where {S,D<:AbstractAgentDefinition,I}\n\nReturn the index and the longitudinal distance of the vehicle that is in the same lane as scene[vehicleindex] and in front of it with the smallest distance along the lane. The result is returned as a NeighborLongitudinalResult object. The method will search on the current lane first, and if no vehicle is found it will continue to travel along the lane following nextlane(lane, roadway). If no vehicle is found within max_distance_fore, the index takes a value of nothing.\n\nNotes on the optional arguments:\n\ntargetpoint_primary::VehicleTargetPoint the reference point whose distance we want to minimize\ntargetpoint_valid::VehicleTargetPoint the reference point, which if distance to is positive, we include the vehicle\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveDrivingModels.FrenetRelativePosition","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.FrenetRelativePosition","text":"Project the given point to the same lane as the given RoadIndex.\n\nThis will return the projection of the point, along with the Δs along the lane from the RoadIndex.\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#Lane-Features-1","page":"Feature Extraction [WIP]","title":"Lane Features","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"    get_lane_width\n    get_markerdist_left\n    get_markerdist_right","category":"page"},{"location":"feature_extraction/#AutomotiveDrivingModels.get_lane_width","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.get_lane_width","text":"get_lane_width(veh::Entity, roadway::Roadway)\n\nReturns the width of the lane where veh is.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveDrivingModels.get_markerdist_left","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.get_markerdist_left","text":"get_markerdist_left(veh::Entity, roadway::Roadway)\n\ndistance of veh to the left marker of the lane\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveDrivingModels.get_markerdist_right","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.get_markerdist_right","text":"get_markerdist_left(veh::Entity, roadway::Roadway)\n\ndistance of veh to the right marker of the lane\n\n\n\n\n\n","category":"function"},{"location":"examples/crosswalk/#Crosswalk-1","page":"Crosswalk","title":"Crosswalk","text":"","category":"section"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"In this notebook we demonstrate how to define a crosswalk with pedestrians using AutomotiveDrivingModels. To do this, we define a crosswalk area as well as a pedestrian agent type.","category":"page"},{"location":"examples/crosswalk/#Generate-a-crosswalk-environment-1","page":"Crosswalk","title":"Generate a crosswalk environment","text":"","category":"section"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"We define a new concrete type that will contain the roadway (where cars drive) and the crosswalk definition which is just a regular lane.","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"using AutomotiveDrivingModels\nusing AutoViz\nAutoViz.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Random\n\nstruct CrosswalkEnv\n    roadway::Roadway{Float64}\n    crosswalk::Lane{Float64}\nend","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"The crosswalk lane consists of a straight road segment perpendicular to the road. We will define the roadway just as a straight road.","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"# geometry parameters\nroadway_length = 50.\ncrosswalk_length = 20.\ncrosswalk_width = 6.0\ncrosswalk_pos = roadway_length/2\n\n# Generate a straight 2-lane roadway and a crosswalk lane\nroadway = gen_straight_roadway(2, roadway_length) \ncrosswalk_start = VecE2(crosswalk_pos, -crosswalk_length/2)\ncrosswalk_end = VecE2(crosswalk_pos, crosswalk_length/2)\ncrosswalk_lane = gen_straight_curve(crosswalk_start, crosswalk_end, 2)\ncrosswalk = Lane(LaneTag(2,1), crosswalk_lane, width = crosswalk_width)\ncw_segment = RoadSegment(2, [crosswalk])\npush!(roadway.segments, cw_segment) # append it to the roadway\n\n# initialize crosswalk environment\nenv = CrosswalkEnv(roadway, crosswalk)\nnothing # hide","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"Render the crosswalk","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"We will define a new method to render this new environment. The roadway part is just rendered regularly, we add specific instuction for the crosswalk part that will display the white stripes.","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"using Cairo\n\nfunction AutoViz.add_renderable!(rendermodel::RenderModel, env::CrosswalkEnv)\n\n    # render the road without the crosswalk\n    roadway = gen_straight_roadway(2, roadway_length)\n    add_renderable!(rendermodel, roadway)\n    \n    # render crosswalk\n    curve = env.crosswalk.curve\n    n = length(curve)\n    pts = Array{Float64}(undef, 2, n)\n    for (i,pt) in enumerate(curve)\n        pts[1,i] = pt.pos.x\n        pts[2,i] = pt.pos.y\n    end\n\n    add_instruction!(\n        rendermodel, render_dashed_line,\n        (pts, colorant\"white\", env.crosswalk.width, 1.0, 1.0, 0.0, Cairo.CAIRO_LINE_CAP_BUTT)\n    )\n    return rendermodel\nend\n\nsnapshot = render([env])\nwrite(\"crosswalk.svg\", snapshot) # hide","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"(Image: crosswalk)","category":"page"},{"location":"examples/crosswalk/#Navigate-the-crosswalk-example-1","page":"Crosswalk","title":"Navigate the crosswalk example","text":"","category":"section"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"Cars will be navigating in the roadway just as before. For the pedestrian we can define a new vehicle definition where we specify the size of the bounding box represented by the pedestrian.","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"# field of the VehicleDef type\nfieldnames(VehicleDef)\n# Agent.Class is from AutomotiveDrivingModels\nconst PEDESTRIAN_DEF = VehicleDef(AgentClass.PEDESTRIAN, 1.0, 1.0)\nnothing # hide","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"# Car definition\ncar_initial_state = VehicleState(VecSE2(5.0, 0., 0.), roadway.segments[1].lanes[1],roadway, 8.0)\ncar = Entity(car_initial_state, VehicleDef(), :car)\n\n# Pedestrian definition using our new Vehicle definition\nped_initial_state = VehicleState(VecSE2(+24.5,-7.0,π/2), env.crosswalk, roadway, 0.5)\nped = Entity(ped_initial_state, PEDESTRIAN_DEF, :pedestrian)\n\nscene = Frame([car, ped])\n\n# visualize the initial state\nsnapshot = render([env, scene])\nwrite(\"crosswalk_initial.svg\", snapshot) # hide","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"(Image: initial state of crosswalk)","category":"page"},{"location":"examples/crosswalk/#Simulate-the-scenario-1","page":"Crosswalk","title":"Simulate the scenario","text":"","category":"section"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"As before, associate a driver model to each vehicle in the scene. We will use the model defined in the intersection example for both agents.","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"mutable struct LinearDriver <: DriverModel{LaneFollowingAccel}\n    a::LaneFollowingAccel\n    p::Float64 # confidence on the pedestrian intention\n    k::Float64 # gain\nend\n\nAutomotiveDrivingModels.get_name(model::LinearDriver) = \"linear driver\"\n\nfunction AutomotiveDrivingModels.observe!(model::LinearDriver, scene::Frame, roadway::Roadway, egoid) \n    model.a = LaneFollowingAccel(model.k*model.p)\n    # change the confidence based on some policy\n    # you can get the position of the pedestrian from the scene\n    model.p = 100.0\nend\nBase.rand(rng::AbstractRNG, model::LinearDriver) = model.a","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"timestep = 0.1\nnticks = 50\n\n# define a model for each entities present in the scene\nmodels = Dict{Symbol, DriverModel}()\n\n# Constant speed model\nmodels[:car] = LinearDriver(LaneFollowingAccel(0.0), 20.0, -0.02)\nmodels[:pedestrian] = IntelligentDriverModel(v_des=1.0)\n\n# execute the simulation\nscenes = simulate(scene, roadway, models, nticks, timestep)\nnothing # hide","category":"page"},{"location":"examples/crosswalk/#Generate-a-video-with-Reel.jl-1","page":"Crosswalk","title":"Generate a video with Reel.jl","text":"","category":"section"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"using Reel\n\nfunction animate_record(scenes::Vector{Frame{E}},dt::Float64, env::CrosswalkEnv) where {E<:Entity}\n    duration = length(scenes)*dt::Float64\n    fps = Int(1/dt)\n    function render_rec(t, dt)\n        frame_index = Int(floor(t/dt)) + 1\n        return render([env, scenes[frame_index]])\n    end\n    return duration, fps, render_rec\nend\n\nduration, fps, render_hist = animate_record(scenes, timestep, env)\nfilm = roll(render_hist, fps=fps, duration=duration)\nwrite(\"crosswalk_animated.gif\", film) # hide\nnothing # hide","category":"page"},{"location":"examples/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"(Image: animated crosswalk)","category":"page"},{"location":"examples/sidewalk/#Sidewalk-1","page":"Sidewalk","title":"Sidewalk","text":"","category":"section"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"In this notebook, we will be creating a sidewalk environment in which  pedestrians can walk along the sidewalk and cross the street as cars pass.","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"using Parameters\nusing AutomotiveDrivingModels\nusing AutoViz\nAutoViz.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Cairo\n\n# Define sidewalk IDs\nconst TOP = 1\nconst BOTTOM = 2\nnothing # hide","category":"page"},{"location":"examples/sidewalk/#Creating-the-Environment-1","page":"Sidewalk","title":"Creating the Environment","text":"","category":"section"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Here, we create a new type of environment called SidewalkEnv. It consists of a roadway, crosswalk, and sidewalk. A sidewalk is a Vector of Lanes that run alongside the road.","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"@with_kw mutable struct SidewalkEnv\n    roadway::Roadway\n    crosswalk::Lane\n    sidewalk::Vector{Lane}\nend;\nnothing # hide","category":"page"},{"location":"examples/sidewalk/#Defining-the-Sidewalk-1","page":"Sidewalk","title":"Defining the Sidewalk","text":"","category":"section"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"We define the sidewalk's parameters.","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"# Geometry parameters\nroadway_length = 100.\ncrosswalk_length = 15.\ncrosswalk_width = 6.0\ncrosswalk_pos = roadway_length/2\nsidewalk_width = 3.0\nsidewalk_pos = crosswalk_length/2 - sidewalk_width / 2\nnothing # hide","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Now we create the sidewalk environment.  Our environment will consist of:","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"1-way road with 2 lanes\nUnsignalized zebra crosswalk perpendicular to the road\nSidewalks above and below the road","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"# Generate straight roadway of length roadway_length with 2 lanes.\n# Returns a Roadway type (Array of segments).\n# There is already a method to generate a simple straight roadway, which we use here.\nroadway = gen_straight_roadway(2, roadway_length) \n\n# Generate the crosswalk.\n# Our crosswalk does not have a predefined method for generation, so we define it with a LaneTag and a curve.\nn_samples = 2 # for curve generation\ncrosswalk = Lane(LaneTag(2,1), gen_straight_curve(VecE2(crosswalk_pos, -crosswalk_length/2),\n                                                  VecE2(crosswalk_pos, crosswalk_length/2),\n                                                   n_samples), width = crosswalk_width)\ncw_segment = RoadSegment(2, [crosswalk])\npush!(roadway.segments, cw_segment) # Append the crosswalk to the roadway\n\n# Generate the sidewalk.\ntop_sidewalk = Lane(LaneTag(3, TOP), gen_straight_curve(VecE2(0., sidewalk_pos),\n                                                      VecE2(roadway_length, sidewalk_pos),\n                                                        n_samples), width = sidewalk_width)\nbottom_sidewalk = Lane(LaneTag(3, BOTTOM), gen_straight_curve(VecE2(0., -(sidewalk_pos - sidewalk_width)),\n                                                          VecE2(roadway_length, -(sidewalk_pos - sidewalk_width)),\n                                                            n_samples), width = sidewalk_width) \n    # Note: we subtract the sidewalk_width from the sidewalk position so that the edge is flush with the road.\n\n\nsw_segment = RoadSegment(3, [top_sidewalk, bottom_sidewalk])\npush!(roadway.segments, sw_segment)\n\n# Initialize crosswalk environment\nenv = SidewalkEnv(roadway, crosswalk, [top_sidewalk, bottom_sidewalk]);\nnothing # hide","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Since there is no defined add_renderable! method for the crosswalk and the sidewalk, we must define it ourselves.","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"function AutoViz.add_renderable!(rendermodel::RenderModel, env::SidewalkEnv)\n    # Render sidewalk\n    for sw in env.sidewalk\n        curve = sw.curve\n        n = length(curve)\n        pts = Array{Float64}(undef, 2, n)\n        for (i,pt) in enumerate(curve)\n            pts[1,i] = pt.pos.x\n            pts[2,i] = pt.pos.y\n        end\n        add_instruction!(rendermodel, render_line, (pts, colorant\"grey\", sw.width, Cairo.CAIRO_LINE_CAP_BUTT))\n    end\n    \n    # Render roadway\n    roadway = gen_straight_roadway(2, roadway_length)\n    add_renderable!(rendermodel, roadway)\n    \n    # Render crosswalk\n    curve = env.crosswalk.curve\n    n = length(curve)\n    pts = Array{Float64}(undef, 2, n)\n    for (i,pt) in enumerate(curve)\n        pts[1,i] = pt.pos.x\n        pts[2,i] = pt.pos.y\n    end\n\n    # We can add render instructions from AutoViz.\n    # Here we want the crosswalk to appear as a white-striped zebra crossing rather than a road.\n    add_instruction!(rendermodel, render_dashed_line, (pts, colorant\"white\", env.crosswalk.width, 1.0, 1.0, 0.0, Cairo.CAIRO_LINE_CAP_BUTT))\n\n    return rendermodel\nend","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"render([env]);","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Now we can define our pedestrian.","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"# We define its class and the dimensions of its bounding box.\nconst PEDESTRIAN_DEF = VehicleDef(AgentClass.PEDESTRIAN, 1.0, 1.0)\nnothing # hide","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"We assign models to each agent in the scene.","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"timestep = 0.1\n\n# Crossing pedestrian definition\nped_init_state = VehicleState(VecSE2(49.0,-3.0,0.), env.sidewalk[BOTTOM], roadway, 1.3)\nped = Entity(ped_init_state, PEDESTRIAN_DEF, :pedestrian)\n\n# Car definition\ncar_initial_state = VehicleState(VecSE2(0.0, 0., 0.), roadway.segments[1].lanes[1],roadway, 8.0)\ncar = Entity(car_initial_state, VehicleDef(), :car)\n\nscene = Frame([ped, car])\n\n# Define a model for each entity present in the scene\nmodels = Dict{Symbol, DriverModel}(\n    :pedestrian => SidewalkPedestrianModel(\n        timestep=timestep, crosswalk=env.crosswalk,\n        sw_origin = env.sidewalk[BOTTOM], sw_dest = env.sidewalk[TOP]\n    ),\n    :car        => LatLonSeparableDriver( # produces LatLonAccels\n        ProportionalLaneTracker(), # lateral model\n        IntelligentDriverModel(), # longitudinal model\n    )\n)\nnothing # hide","category":"page"},{"location":"examples/sidewalk/#Simulate-1","page":"Sidewalk","title":"Simulate","text":"","category":"section"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Finally, we simulate and visualize the scene.","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"using Reel\n\nnticks = 300\nscenes = simulate(scene, roadway, models, nticks, timestep)\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    render([env, scenes[i]])\nend;\nwrite(\"sidewalk_animation.gif\", animation); # hide\nnothing # hide","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"(Image: sidewalk animation)","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"We can use a slider to scroll through each frame in the simulation. This usually takes less time than rendering a video.","category":"page"},{"location":"examples/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"using Interact\nusing Reel\nusing Blink\n\nw = Window()\nviz = @manipulate for i in 1 : length(scenes)\n    render([env, scenes[i]])\nend\nbody!(w, viz)","category":"page"},{"location":"simulation/#Simulation-1","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"Simulations can be run using the simulate! function.  A simulation updates the initial scene forward in time. Each simulation step consists of the following operations:","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"call the observe! function for each vehicle to update their driver model given the current scene \nsample an action from the driver model by calling rand on the driver model.\nupdate the state of each vehicle using the sampled action and the propagate method.\nrepeat for the desired number of steps","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"There are two main ways to call the simulate! function:","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"simulate!(scene::Frame{E}, roadway::R, models::Dict{I,M}, nticks::Int64, timestep::Float64; rng::AbstractRNG = Random.GLOBAL_RNG, scenes::Vector{Frame{E}} = [Frame(E, length(scene)) for i=1:nticks+1], callbacks = nothing) which simply returns a vector of scenes. This vector can be pre-allocated and passed as a keyword argument. The randomness of the simulation can be controlled by passing a random number generator. \nsimulate!(rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M}, nticks::Int, callbacks::C) which fills in a given QueueRecord object. The QueueRecord data structure is defined in Records.jl. This methods is slower and suffers from type stability issues. It will be deprecated in future releases.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"See the tutorials for examples.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    simulate!\n    get_actions!\n    tick!","category":"page"},{"location":"simulation/#AutomotiveDrivingModels.simulate!","page":"Simulation","title":"AutomotiveDrivingModels.simulate!","text":"DEPRECATION WARNING: this version of simulate! is now deprecated.\n\nsimulate!(scene::Frame{E}, roadway::R, models::Dict{I,M<:DriverModel}, nticks::Int64, timestep::Float64; rng::AbstractRNG = Random.GLOBAL_RNG, scenes::Vector{Frame{E}} = [Frame(E, length(scene)) for i=1:nticks+1], callbacks=nothing)\n\nRun nticks steps of simulation with time step dt and return a vector of scenes from time step 0 to nticks.\n\nsimulate!(::Type{A}, rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M<:DriverModel}, nticks::Int)\nsimulate!(rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M<:DriverModel}, nticks::Int)\n\nRun nticks of simulation and place all nticks+1 scenes into the QueueRecord\n\nsimulate!(::Type{A},rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M}, nticks::Int, callbacks::C) where {S,D,I,A,R,M<:DriverModel,C<:Tuple{Vararg{Any}}}\nsimulate!(rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M}, nticks::Int, callbacks::C) where {S,D,I,A,R,M<:DriverModel,C<:Tuple{Vararg{Any}}}\n\nCallback objects can also be passed in the simulate! function.\n\n\n\n\n\nsimulate!(\n    scene::Frame{E}, roadway::R, models::Dict{I,M},\n    nticks::Int64, timestep::Float64,\n    scenes::Vector{Frame{E}}, actions::Union{Nothing, Vector{Frame{A}}} = nothing;\n    rng::AbstractRNG = Random.GLOBAL_RNG, callbacks = nothing\n) where {E<:Entity,A<:EntityAction,R,I,M<:DriverModel}\n\nSimulate the entities in scene along a roadway for a maximum of nticks time steps of size timestep. Returns the number of successfully performed timesteps.\n\nAt each time step, models is used to determine the action for each agent. scenes and actions are pre-allocated vectors of Frames containing either Entitys (for scenes) or EntityActions (for actions). If actions is equal to nothing (default), the action history is not tracked. scenes must always be provided.\n\ncallbacks is an array of callback functions which are invoked before the simulation starts and after every simulation step. Any callback function can cause an early termination by returning true (the default return value for callback functions should be false). The random number generator for the simulation can be provided using the rng keyword argument, it defaults to Random.GLOBAL_RNG.\n\n\n\n\n\nRun a simulation and store the resulting scenes in the provided QueueRecord.\n\nOnly the ego vehicle is simulated; the other vehicles are as they were in the provided trajdata Other vehicle states will be interpolated\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveDrivingModels.get_actions!","page":"Simulation","title":"AutomotiveDrivingModels.get_actions!","text":"get_actions!(actions::Vector{A}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I, M},) where {S,D,I,A,R,M<:DriverModel}\n\nFill in actions with the actions of each agent present in the scene. It calls observe! and rand for each driver models.  actions will contain the actions to apply to update the state of each vehicle.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveDrivingModels.tick!","page":"Simulation","title":"AutomotiveDrivingModels.tick!","text":"tick!(scene::EntityFrame{S,D,I}, roadway::R, actions::Vector{A}, Δt::Float64) where {S,D,I,A,R}\n\nupdate scene in place by updating the state of each vehicle given their current action in actions.  It calls the propagate method for each vehicle in the scene.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#Callbacks-1","page":"Simulation","title":"Callbacks","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"One can define callback functions that will be run at each simulation step. The callback function can terminate the simulation by returning true. The default return value of a callback function should be false. Callback functions are also useful to log simulation information. ","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"To run a custom callback function in the simulation loop, you must implement a custom callback type and an associated run_callback method for that type with the following signature","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"function AutomotiveDrivingModels.run_callback(\n    cb::ReachGoalCallback,\n    scenes::Vector{Frame{E}},\n    actions::Vector{Frame{A}},\n    roadway::R,\n    models::Dict{I,M},\n    tick::Int,\n    ) where {E<:Entity,A<:EntityAction,R,I,M<:DriverModel}\nend","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"The scenes object holds a snapshot of a scene at each timestep in the range 1:tick, and the actions object holds a frame of EntityActions which record the action of each vehicle for the time steps 1:(tick-1).","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"Here is an example of a callback that checks if a vehicle's longitudinal position has reached some goal position and stops the simulation if it is the case.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"struct ReachGoalCallback # a callback that checks if vehicle veh_id has reach a certain position \n    goal_pos::Float64\n    veh_id::Int64\nend \n\nfunction AutomotiveDrivingModels.run_callback(\n    cb::ReachGoalCallback,\n    scenes::Vector{Frame{E}},\n    actions::Vector{Frame{A}},\n    roadway::R,\n    models::Dict{I,M},\n    tick::Int,\n    ) where {E<:Entity,A<:EntityAction,R,I,M<:DriverModel}\n    veh = get_by_id(last(scenes), cb.veh_id)\n    return veh.state.posF.s > cb.goal_pos \nend","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"A callback for collision is already implemented: CollisionCallback.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    run_callback\n    CollisionCallback","category":"page"},{"location":"simulation/#AutomotiveDrivingModels.run_callback","page":"Simulation","title":"AutomotiveDrivingModels.run_callback","text":"# TODO: this should be removed, but where to document the function then?\nrun_callback(callback::Any, scenes::Vector{F}, roadway::R, models::Dict{I,M}, tick::Int) where {F,I,R,M<:DriverModel}    \nrun_callback(callback::Any, rec::EntityQueueRecord{S,D,I}, roadway::R, models::Dict{I,M}, tick::Int) where {S,D,I,R,M<:DriverModel}\n\nrun callback and return whether simlation should terminate A new method should be implemented when defining a new callback object.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveDrivingModels.CollisionCallback","page":"Simulation","title":"AutomotiveDrivingModels.CollisionCallback","text":"CollisionCallback\n\nTerminates the simulation once a collision occurs\n\n\n\n\n\n","category":"type"},{"location":"simulation/#Others-1","page":"Simulation","title":"Others","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    reset_hidden_states!","category":"page"},{"location":"simulation/#AutomotiveDrivingModels.reset_hidden_states!","page":"Simulation","title":"AutomotiveDrivingModels.reset_hidden_states!","text":"reset_hidden_states!(models::Dict{Int,M}) where {M<:DriverModel}\n\nreset hidden states of all driver models in models\n\n\n\n\n\n","category":"function"},{"location":"examples/intersection/#Intersection-1","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"In this example we demonstrate how to define a T-shape intersection with AutomotiveDrivingModels. You will also learn how to define your own custom action type and driver model type.","category":"page"},{"location":"examples/intersection/#Generate-a-T-Shape-intersection-1","page":"Intersection","title":"Generate a T-Shape intersection","text":"","category":"section"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"In order to generate the road network, we first initialize a Roadway object.","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"using AutomotiveDrivingModels\nusing AutoViz\nAutoViz.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Random\n\nroadway = Roadway()\nnothing # hide","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"Define coordinates of the entry and exit points to the intersection","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"r = 5.0 # turn radius\nw = DEFAULT_LANE_WIDTH\n\nA = VecSE2(0.0,w,-π)\nB = VecSE2(0.0,0.0,0.0)\nC = VecSE2(r,-r,-π/2)\nD = VecSE2(r+w,-r,π/2)\nE = VecSE2(2r+w,0,0)\nF = VecSE2(2r+w,w,-π)\nnothing # hide","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"The next step consists in appending all the lanes to the road network. We can define a helper function to add a new lane to the roadway.","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"function append_to_curve!(target::Curve, newstuff::Curve)\n    s_end = target[end].s\n    for c in newstuff\n        push!(target, CurvePt(c.pos, c.s+s_end, c.k, c.kd))\n    end\n    return target\nend\nnothing # hide","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"Example of a lane that consists of 3 road segments, a straight curve (from the left to the center), a turning part (right turn) and a final  straight curve.","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"# Append right turn coming from the left\ncurve = gen_straight_curve(convert(VecE2, B+VecE2(-100,0)), convert(VecE2, B), 2)\nappend_to_curve!(curve, gen_bezier_curve(B, C, 0.6r, 0.6r, 51)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, C), convert(VecE2, C+VecE2(0,-50.0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))\n\n# visualize the current lane constellation\nsnapshot = render([roadway])\nwrite(\"partial_intersection.svg\", snapshot) # hide","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: partial intersection)","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"Let's repeat the process and complete the T-shape intersection","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"# Append straight left\ncurve = gen_straight_curve(convert(VecE2, B+VecE2(-100,0)), convert(VecE2, B), 2)\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, B), convert(VecE2, E), 2)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, E), convert(VecE2, E+VecE2(50,0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))\n\n# Append straight right\ncurve = gen_straight_curve(convert(VecE2, F+VecE2(50,0)), convert(VecE2, F), 2)\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, F), convert(VecE2, A), 2)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, A), convert(VecE2, A+VecE2(-100,0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))\n\n# Append left turn coming from the right\ncurve = gen_straight_curve(convert(VecE2, F+VecE2(50,0)), convert(VecE2, F), 2)\nappend_to_curve!(curve, gen_bezier_curve(F, C, 0.9r, 0.9r, 51)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, C), convert(VecE2, C+VecE2(0,-50)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))\n\n# Append right turn coming from below\ncurve = gen_straight_curve(convert(VecE2, D+VecE2(0,-50)), convert(VecE2, D), 2)\nappend_to_curve!(curve, gen_bezier_curve(D, E, 0.6r, 0.6r, 51)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, E), convert(VecE2, E+VecE2(50,0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))\n\n# Append left turn coming from below\ncurve = gen_straight_curve(convert(VecE2, D+VecE2(0,-50)), convert(VecE2, D), 2)\nappend_to_curve!(curve, gen_bezier_curve(D, A, 0.9r, 0.9r, 51)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, A), convert(VecE2, A+VecE2(-100,0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))\n\nsnapshot = render([roadway])\nwrite(\"intersection.svg\", snapshot) # hide","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: intersection)","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"We can identify each lane thanks to the following user-defined functions. We define a LaneOverlay object that indicate the lane to highlight. One could implement any custom type to display other information on the lane. We then add a new method to the add_renderable! function that execute the specific action (coloring in blue). Look at Autoviz.jl for more detail on the function add_renderable!.","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"The following animation iterates over the individual lanes of the intersection layout and highlights them:","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"struct LaneOverlay <: SceneOverlay\n    roadway::Roadway\n    lane::Lane\n    color::Colorant\nend\nfunction AutoViz.add_renderable!(rendermodel::RenderModel, overlay::LaneOverlay)\n    add_renderable!(rendermodel, overlay.lane, overlay.roadway, color_asphalt=overlay.color)\nend\n\n\nusing Reel\n\nanimation = roll(fps=1.0, duration=length(roadway.segments)) do t, dt\n    i = Int(floor(t/dt)) + 1\n    renderables = [\n        roadway,\n        LaneOverlay(roadway, roadway[LaneTag(i,1)], RGBA(0.0,0.0,1.0,0.5))\n    ]\n    render(renderables)\nend;\n\nwrite(\"highlighted_lanes.gif\", animation) # hide\nnothing # hide","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: highlighted lanes)","category":"page"},{"location":"examples/intersection/#Navigation-in-the-new-road-network-1","page":"Intersection","title":"Navigation in the new road network","text":"","category":"section"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"Let's populate the intersection","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"vs0 = VehicleState(B + polar(50.0,-π), roadway, 8.0) # initial state of the vehicle\nscene = Scene([Vehicle(vs0, VehicleDef(), 1)])\n\nsnapshot = render([roadway, scene])\nwrite(\"intersection_populated.svg\", snapshot) # hide","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: populated intersection)","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"We will use lateral and longitudinal acceleration to control a car in the intersection. The first step is to define a corresponding action type that will contain the acceleration inputs.","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"struct LaneSpecificAccelLatLon\n    a_lat::Float64\n    a_lon::Float64\nend","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"Next, add a method to the propagate function to update the state using our new action type. ","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"function AutomotiveDrivingModels.propagate(veh::Vehicle, action::LaneSpecificAccelLatLon, roadway::Roadway, Δt::Float64)\n    lane_tag_orig = veh.state.posF.roadind.tag\n    state = propagate(veh, LatLonAccel(action.a_lat, action.a_lon), roadway, Δt)\n    roadproj = proj(state.posG, roadway[lane_tag_orig], roadway, move_along_curves=false)\n    retval = VehicleState(Frenet(roadproj, roadway), roadway, state.v)\n    return retval\nend","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"Driver Model:","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"We define a driver model, which can be seen as a distribution over actions.  # TODO Here we will define the simplest model, which is to repeat the same action.","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"struct InterDriver <: DriverModel{LaneSpecificAccelLatLon}\n    a::LaneSpecificAccelLatLon\nend\nAutomotiveDrivingModels.get_name(model::InterDriver) = \"InterDriver\"\nAutomotiveDrivingModels.observe!(model::InterDriver, scene::Scene, roadway::Roadway, egoid::Int64) = model\nBase.rand(::AbstractRNG, model::InterDriver) = model.a","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"Simulate:","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"First associate a model to each driver in the scene using a dictionary. Here we only have one driver identified by its ID: 1. Then everything is ready to run the simulate! function.","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"using Reel\n\ntimestep = 0.1\nnticks = 100\n\nvs0 = VehicleState(B + polar(50.0,-π), roadway, 8.0)\nscene = Scene([Vehicle(vs0, VehicleDef(), 1)])\nmodels = Dict(1 => InterDriver(LaneSpecificAccelLatLon(0.0,0.0)))\nscenes = simulate!(scene, roadway, models, nticks, timestep)\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    renderables = [roadway, scenes[i]]\n    render(renderables)\nend\n\nwrite(\"animated_intersection.gif\", animation) # hide","category":"page"},{"location":"examples/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: animated intersection)","category":"page"},{"location":"examples/straight_roadway/#Driving-on-a-Straight-Roadway-1","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"","category":"section"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"This notebook demonstrates a simple, one-dimensional driving simulation in which cars drive along a straight roadway. The types are:","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"S - State1D, containing the vehicle position and speed\nD - VehicleDef, containing length, width, and class\nI - Int, a unique label for each vehicle`","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"We use a StraightRoadway as our environment and LaneFollowingDrivers that produce LaneFollowingAccels.","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"using AutomotiveDrivingModels\nusing AutoViz\nAutoViz.colortheme[\"background\"] = colorant\"white\"; # hide\n\nroadway = StraightRoadway(200.)  # 200m long straight roadway\nscene = Scene1D([\n    Entity(State1D(10.0,  8.0), VehicleDef(), 1),\n    Entity(State1D(50.0, 12.5), VehicleDef(), 2),\n    Entity(State1D(150.0, 6.0), VehicleDef(), 3),\n])\n\ncamera = StaticCamera(position=VecE2(100.0,0.0), zoom=4.75, canvas_height=100)\nrenderables = [roadway, scene]::Vector{Any}\nsnapshot = render(renderables, camera=camera)\nwrite(\"straight_roadway.svg\", snapshot) # hide","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"(Image: three cars on road)","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"In the call to the render function, we used the default rendering behavior for entities. More advanced examples will show how the rendering of entities can be customized.","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"We can add an overlay that displays the car id:","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"for veh in scene\n    push!(renderables, \n        TextOverlay(text=[\"$(veh.id)\"], coordinate_system=:scene, pos=VecE2(veh.state.s-0.7, 3))\n    )\nend\nsnapshot = render(renderables, camera=camera)\nwrite(\"straight_roadway_with_id.svg\", snapshot) # hide","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"(Image: three cars with id)","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"Alternatively, we can create a new SceneOverlay object which takes care of displaying information for us:","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"using Parameters\n@with_kw struct CarIDOverlay <: SceneOverlay\n    scene::Scene1D\n    roadway::StraightRoadway\n    textparams::TextParams=TextParams()\nend\nfunction AutoViz.add_renderable!(rendermodel::RenderModel, overlay::CarIDOverlay)\n    for veh in overlay.scene\n        x = veh.state.s - 0.7\n        y = 3.0\n        text = string(veh.id)\n        add_instruction!(rendermodel, render_text, (text, x, y, overlay.textparams.size, overlay.textparams.color), coordinate_system=:scene)\n    end\n    return rendermodel\nend\n\nsnapshot = render([roadway, scene, CarIDOverlay(scene=scene, roadway=roadway)], camera=camera)\nwrite(\"straight_roadway_with_overlay.svg\", snapshot) # hide","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"(Image: three vehicles with custom overlay)","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"To run a simulation we need driving models that produce actions. For this we will use LaneFollowingDrivers that produce LaneFollowingAccels. For this demo, we will give each car a different model.","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"models = Dict{Int, LaneFollowingDriver}(\n    1 => StaticLaneFollowingDriver(0.0), # always produce zero acceleration\n    2 => IntelligentDriverModel(v_des=12.0), # default IDM with a desired speed of 12 m/s\n    3 => PrincetonDriver(v_des = 10.0), # default Princeton driver with a desired speed of 10m/s\n)\n\nnticks = 100\ntimestep = 0.1\nscenes = simulate(scene, roadway, models, nticks, timestep)\nnothing # hide","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"We can visualize the simulation as a sequence of images, for example using the Reel package","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"using Reel\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    renderables = [roadway, scenes[i], CarIDOverlay(scene=scenes[i], roadway=roadway)]\n    render(renderables, camera=camera)\nend\nwrite(\"straight_roadway_animated.gif\", animation) # hide\nnothing # hide","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"(Image: three vehicles animated)","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"In order to inspect the simulation interactively, we can use the Interact package","category":"page"},{"location":"examples/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"using Interact\nusing Blink\nusing ElectronDisplay\n\nw = Window()\nviz = @manipulate for step in 1 : length(scenes)\n    renderables = [roadway, scenes[step], CarIDOverlay(scene=scenes[step], roadway=roadway)]\n    render(renderables, camera=camera)\nend\nbody!(w, viz)","category":"page"},{"location":"Roadways/#Roadways-1","page":"Roadways","title":"Roadways","text":"","category":"section"},{"location":"Roadways/#Data-Types-and-Accessing-Elements-1","page":"Roadways","title":"Data Types and Accessing Elements","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The data structure to represent roadways can be decomposed as follows:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Roadway The high level type containing all the information. It contains a list of RoadSegment.\nRoadSegment: a vector of lanes\nLane: A driving lane on a roadway. It identified by a LaneTag. A lane is defined by a curve which","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"represents a center line and a width. In addition it has attributed like speed limit. A lane can be connected to other lane in the roadway, the connection are specified in the exits and entrances fields.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Lower level types:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Curves: A curve is a list of CurvePt\nCurvePt: the lowest level type. It represents a point on a curve by its global position, position along the curve, curvature at this point and derivative of the curvature at this point. Other types like CurveIndex or CurveProjection are used to identify a curve point along a curve. ","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Roadway\n      RoadSegment\n      move_along","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.Roadway","page":"Roadways","title":"AutomotiveDrivingModels.Roadway","text":"Roadway\n\nThe main datastructure to represent road network, it consists of a list of RoadSegment\n\nFields\n\nsegments::Vector{RoadSegment}\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.RoadSegment","page":"Roadways","title":"AutomotiveDrivingModels.RoadSegment","text":"RoadSegment{T}\n\na list of lanes forming a single road with a common direction\n\nFields\n\nid::Int64\nlanes::Vector{Lane{T}} lanes are stored right to left\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.move_along","page":"Roadways","title":"AutomotiveDrivingModels.move_along","text":"move_along(roadind::RoadIndex, road::Roadway, Δs::Float64)\n\nReturn the RoadIndex at ind's s position + Δs\n\n\n\n\n\nmove_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64;\nϕ₂::Float64=vehstate.posF.ϕ, t₂::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n\nreturns a vehicle state after moving vehstate of a length Δs along its lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Roadway-generation-1","page":"Roadways","title":"Roadway generation","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"AutomotiveDrivingModels.jl provide high level functions to generate road networks by drawing straight road segment and circular curves. Two predefined road network can be generated easily: multi-lane straight roadway sections and a multi-lane stadium shaped roadway.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      gen_straight_curve\n      gen_straight_segment\n      gen_bezier_curve\n      gen_straight_roadway\n      gen_stadium_roadway","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.gen_straight_curve","page":"Roadways","title":"AutomotiveDrivingModels.gen_straight_curve","text":"gen_straight_curve(A::VecE2{T}, B::VecE2{T}, nsamples::Integer) where T<:Real\n\nReturns a Curve corresponding to a straight line between A and B. nsamples indicates the number of points to place between A and B, if set to two, the curve will only contains A and B.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.gen_straight_segment","page":"Roadways","title":"AutomotiveDrivingModels.gen_straight_segment","text":"gen_straight_segment(seg_id::Integer, nlanes::Integer, length::Float64=1000.0;\n\nGenerate a straight RoadSegment with nlanes number of lanes of length length.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.gen_bezier_curve","page":"Roadways","title":"AutomotiveDrivingModels.gen_bezier_curve","text":"gen_bezier_curve(A::VecSE2{T}, B::VecSE2{T}, rA::T, rB::T, nsamples::Int) where T <: Real\n\nGenerate a Bezier curve going from A to B with radii specified by rA and rB. It uses cubic interpolation. nsamples specifies the number of point along the curve between A and B. The more  points, the more accurate the approximation is. This is useful to generate arcs. \n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.gen_straight_roadway","page":"Roadways","title":"AutomotiveDrivingModels.gen_straight_roadway","text":"gen_straight_roadway(nlanes::Int, length::Float64)\n\nGenerate a roadway with a single straight segment whose rightmost lane center starts at starts at (0,0), and proceeds in the positive x direction.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.gen_stadium_roadway","page":"Roadways","title":"AutomotiveDrivingModels.gen_stadium_roadway","text":"gen_stadium_roadway(nlanes::Int; length::Float64=100.0; width::Float64=10.0; radius::Float64=25.0)\n\nGenerate a roadway that is a rectangular racetrack with rounded corners.     length = length of the x-dim straight section for the innermost (leftmost) lane [m]     width  = length of the y-dim straight section for the innermost (leftmost) lane [m]     radius = turn radius [m]\n\n  ______________________\n /                      \\ \n|                        |\n|                        |\n\\______________________/\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Lane-1","page":"Roadways","title":"Lane","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The Lane data structure represent a driving lane in the roadway. The default lane width is 3m. It contains all the low level geometry information.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Lane\n      LaneTag\n      lanes\n      lanetags\n      SpeedLimit\n      LaneBoundary\n      LaneConnection\n      is_in_exits\n      is_in_entrances\n      connect!\n      is_between_segments_hi\n      is_between_segments\n      has_segment\n      has_lanetag\n      next_lane\n      prev_lane\n      has_next\n      has_prev\n      next_lane_point\n      prev_lane_point\n      n_lanes_left\n      n_lanes_right","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.Lane","page":"Roadways","title":"AutomotiveDrivingModels.Lane","text":"Lane\n\nA driving lane on a roadway. It identified by a LaneTag. A lane is defined by a curve which represents a center line and a width. In addition it has attributed like speed limit.  A lane can be connected to other lane in the roadway, the connection are specified in the exits and entrances fields.\n\nFields\n\ntag::LaneTag\ncurve::Curve\nwidth::Float64  [m]\nspeed_limit::SpeedLimit\nboundary_left::LaneBoundary\nboundary_right::LaneBoundary\nexits::Vector{LaneConnection} # list of exits; put the primary exit (at end of lane) first\nentrances::Vector{LaneConnection} # list of entrances; put the primary entrance (at start of lane) first\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.LaneTag","page":"Roadways","title":"AutomotiveDrivingModels.LaneTag","text":"LaneTag\n\nAn identifier for a lane. The lane object can be retrieved by indexing the roadway by the lane tag:\n\ntag = LaneTag(1, 2) # second lane segment 1\nlane = roadway[tag] # returns a Lane object\n\nFields\n\nsegment::Int64 segment id\nlane::Int64 index in segment.lanes of this lane\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.lanes","page":"Roadways","title":"AutomotiveDrivingModels.lanes","text":"lanes(roadway::Roadway{T}) where T\n\nreturn a list of all the lanes present in roadway. \n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.lanetags","page":"Roadways","title":"AutomotiveDrivingModels.lanetags","text":"lanetags(roadway::Roadway)\n\nreturn a list of all the lane tags present in roadway.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.SpeedLimit","page":"Roadways","title":"AutomotiveDrivingModels.SpeedLimit","text":"SpeedLimit\n\nDatastructure to represent a speed limit\n\nFields\n\nlo::Float64 [m/s] lower speed limit \nhi::Float64 [m/s] higher speed limit\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.LaneBoundary","page":"Roadways","title":"AutomotiveDrivingModels.LaneBoundary","text":"LaneBoundary\n\nData structure to represent lanes boundaries such as double yellow lines.\n\nFields\n\n- `style::Symbol` ∈ :solid, :broken, :double\n- `color::Symbol` ∈ :yellow, white\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.LaneConnection","page":"Roadways","title":"AutomotiveDrivingModels.LaneConnection","text":"LaneConnection{I <: Integer, T <: Real}\n\nData structure to specify the connection of a lane. It connects mylane to the point target.  target would typically be the starting point of a new lane.\n\ndownstream::Bool\nmylane::CurveIndex{I,T}\ntarget::RoadIndex{I,T}\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.is_in_exits","page":"Roadways","title":"AutomotiveDrivingModels.is_in_exits","text":"is_in_exits(lane::Lane, target::LaneTag)\n\nreturns true if target is in the exit lanes of lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.is_in_entrances","page":"Roadways","title":"AutomotiveDrivingModels.is_in_entrances","text":"is_in_entrances(lane::Lane, target::LaneTag)\n\nreturns true if target is in the entrances lanes of lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.connect!","page":"Roadways","title":"AutomotiveDrivingModels.connect!","text":"connect!(source::Lane, dest::Lane)\n\nconnect two lanes to each other. Useful for roadway construction.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.is_between_segments_hi","page":"Roadways","title":"AutomotiveDrivingModels.is_between_segments_hi","text":"is_between_segments_hi(ind::CurveIndex, curve::Curve)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.is_between_segments","page":"Roadways","title":"AutomotiveDrivingModels.is_between_segments","text":"is_between_segments(ind::CurveIndex, curve::Curve)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.has_segment","page":"Roadways","title":"AutomotiveDrivingModels.has_segment","text":"has_segment(roadway::Roadway, segid::Int)\n\nreturns true if segid is in roadway.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.has_lanetag","page":"Roadways","title":"AutomotiveDrivingModels.has_lanetag","text":"has_lanetag(roadway::Roadway, tag::LaneTag)\n\nreturns true if roadway contains a lane identified by tag\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.next_lane","page":"Roadways","title":"AutomotiveDrivingModels.next_lane","text":"next_lane(lane::Lane, roadway::Roadway)\n\nreturns the lane connected to the end lane. If lane has several exits, it returns the first one\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.prev_lane","page":"Roadways","title":"AutomotiveDrivingModels.prev_lane","text":"prev_lane(lane::Lane, roadway::Roadway)\n\nreturns the lane connected to the beginning lane. If lane has several entrances, it returns the first one\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.has_next","page":"Roadways","title":"AutomotiveDrivingModels.has_next","text":"has_next(lane::Lane)\n\nreturns true if the end of the lane is connected to another lane (i.e. if it has an exit lane)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.has_prev","page":"Roadways","title":"AutomotiveDrivingModels.has_prev","text":"has_prev(lane::Lane)\n\nreturns true if another lane is connected to the beginning of that lane. (i.e. if it has an entrance lane)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.next_lane_point","page":"Roadways","title":"AutomotiveDrivingModels.next_lane_point","text":"next_lane_point(lane::Lane, roadway::Roadway)\n\nreturns the point of connection between lane and its first exit\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.prev_lane_point","page":"Roadways","title":"AutomotiveDrivingModels.prev_lane_point","text":"prev_lane_point(lane::Lane, roadway::Roadway)\n\nreturns the point of connection between lane and its first entrance\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.n_lanes_left","page":"Roadways","title":"AutomotiveDrivingModels.n_lanes_left","text":"n_lanes_left(lane::Lane, roadway::Roadway)\n\nreturns the number of lanes to the left of lane\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.n_lanes_right","page":"Roadways","title":"AutomotiveDrivingModels.n_lanes_right","text":"n_lanes_right(lane::Lane, roadway::Roadway)\n\nreturns the number of lanes to the right of lane\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Frenet-frame-1","page":"Roadways","title":"Frenet frame","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The Frenet frame is a lane relative frame to represent a position on the road network.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Frenet","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.Frenet","page":"Roadways","title":"AutomotiveDrivingModels.Frenet","text":"Frenet\n\nRepresents a vehicle position and heading in a lane relative frame. \n\nConstructors\n\nFrenet(roadind::RoadIndex, roadway::Roadway; t::Float64=0.0, ϕ::Float64=0.0)\nFrenet(roadproj::RoadProjection, roadway::Roadway)\nFrenet(lane::Lane, s::Float64, t::Float64=0.0, ϕ::Float64=0.0)\nFrenet(posG::VecSE2, roadway::Roadway)\nFrenet(posG::VecSE2, lane::Lane, roadway::Roadway)\n\nFields\n\nroadind: road index\ns: distance along lane\nt: lane offset, positive is to left. zero point is the centerline of the lane.\nϕ: lane relative heading\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#Accessing-objects-and-projections-1","page":"Roadways","title":"Accessing objects and projections","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The main roadway object can be indexed by different object to access different elements such as lane or curve points:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"LaneTag: indexing roadway by a lane tag will return the lane associated to the lane tag \nRoadIndex: indexing roadway by a road index will return the curve point associated to this index","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"  RoadIndex\n  CurveIndex\n  RoadProjection\n  proj(posG::VecSE2{T}, lane::Lane{T}, roadway::Roadway{T};move_along_curves::Bool = true ) where T<: Real\n  proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T<: Real\n  proj(posG::VecSE2{T}, roadway::Roadway) where T<: Real\n  Base.getindex(lane::Lane{T}, ind::CurveIndex{I,T}, roadway::Roadway{T}) where{I<:Integer, T<:Real}\n  Base.getindex(roadway::Roadway, segid::Int)\n  Base.getindex(roadway::Roadway, tag::LaneTag)","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.RoadIndex","page":"Roadways","title":"AutomotiveDrivingModels.RoadIndex","text":"RoadIndex{I <: Integer, T <: Real}\n\nA data structure to index points in a roadway. Calling roadway[roadind] will return the point associated to the road index.\n\nFields\n\nind::CurveIndex{I,T} the index of the point in the curve\ntag::LaneTag the lane tag of the point\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.CurveIndex","page":"Roadways","title":"AutomotiveDrivingModels.CurveIndex","text":"CurveIndex{I <: Integer, T <: Real}\n\nGiven a Curve object curve one can call curve[ind] where ind is a CurveIndex. The field t can be used to interpolate between two  points in the curve. \n\nFields\n\ni::I` index in the curve , ∈ [1:length(curve)-1]\nt::T ∈ [0,1] for linear interpolation\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.RoadProjection","page":"Roadways","title":"AutomotiveDrivingModels.RoadProjection","text":"RoadProjection{I <: Integer, T <: Real}\n\nrepresents the projection of a point on the roadway\n\nFields\n\ncurveproj::CurveProjection{I, T}\ntag::LaneTag\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#Vec.proj-Union{Tuple{T}, Tuple{VecSE2{T},Lane{T},Roadway{T}}} where T<:Real","page":"Roadways","title":"Vec.proj","text":"proj(posG::VecSE2{T}, lane::Lane, roadway::Roadway; move_along_curves::Bool=true) where T <: Real\n\nReturn the RoadProjection for projecting posG onto the lane. This will automatically project to the next or prev curve as appropriate. if move_along_curves is false, will only project to lane.curve\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Vec.proj-Union{Tuple{T}, Tuple{VecSE2{T},RoadSegment,Roadway}} where T<:Real","page":"Roadways","title":"Vec.proj","text":"proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T <: Real\n\nReturn the RoadProjection for projecting posG onto the segment. Tries all of the lanes and gets the closest one\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Vec.proj-Union{Tuple{T}, Tuple{VecSE2{T},Roadway}} where T<:Real","page":"Roadways","title":"Vec.proj","text":"proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T <: Real\n\nReturn the RoadProjection for projecting posG onto the roadway. Tries all of the lanes and gets the closest one\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.getindex-Union{Tuple{T}, Tuple{I}, Tuple{Lane{T},CurveIndex{I,T},Roadway{T}}} where T<:Real where I<:Integer","page":"Roadways","title":"Base.getindex","text":"lane[ind::CurveIndex, roadway::Roadway]\n\nAccessor for lanes based on a CurveIndex. Note that we extend the definition of a CurveIndex, previously ind.i ∈ [1, length(curve)-1], to:\n\nind.i ∈ [0, length(curve)]\n\nwhere 1 ≤ ind.i ≤ length(curve)-1 is as before, but if the index is on the section between two lanes, we use:\n\nind.i = length(curve), ind.t ∈ [0,1] for the region between curve[end] → next\nind.i = 0,             ind.t ∈ [0,1] for the region between prev → curve[1]\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.getindex-Tuple{Roadway,Int64}","page":"Roadways","title":"Base.getindex","text":"Base.getindex(roadway::Roadway, segid::Int)\n\nreturns the segment associated with id segid\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.getindex-Tuple{Roadway,LaneTag}","page":"Roadways","title":"Base.getindex","text":"Base.getindex(roadway::Roadway, tag::LaneTag)\n\nreturns the lane identified by the tag LaneTag\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Low-level-1","page":"Roadways","title":"Low level","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Curve\n      CurvePt\n      CurveProjection\n      is_at_curve_end\n      get_lerp_time\n      index_closest_to_point\n      get_curve_index\n      lerp(A::VecE2{T}, B::VecE2{T}, C::VecE2{T}, D::VecE2{T}, t::T) where T<:Real\n      lerp(A::VecE2{T}, B::VecE2{T}, C::VecE2{T}, t::T) where T<:Real","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.Curve","page":"Roadways","title":"AutomotiveDrivingModels.Curve","text":"Curve{T}\n\nis a vector of curve points\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.CurvePt","page":"Roadways","title":"AutomotiveDrivingModels.CurvePt","text":"CurvePt{T}\n\ndescribes a point on a curve, associated with a curvature and the derivative of the curvature\n\npos::VecSE2{T} # global position and orientation\ns::T  # distance along the curve\nk::T # curvature\nkd::T # derivative of curvature\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.CurveProjection","page":"Roadways","title":"AutomotiveDrivingModels.CurveProjection","text":"CurveProjection{I <: Integer, T <: Real}\n\nThe result of a point projected to a Curve\n\nFields\n\nind::CurveIndex{I, T}\nt::T lane offset \nϕ::T lane-relative heading [rad]\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.is_at_curve_end","page":"Roadways","title":"AutomotiveDrivingModels.is_at_curve_end","text":"is_at_curve_end(ind::CurveIndex, curve::Curve)\n\nreturns true if the curve index is at the end of the curve\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.get_lerp_time","page":"Roadways","title":"AutomotiveDrivingModels.get_lerp_time","text":"get_lerp_time(A::VecE2, B::VecE2, Q::VecE2)\n\nGet lerp time t∈[0,1] such that lerp(A, B) is as close as possible to Q\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.index_closest_to_point","page":"Roadways","title":"AutomotiveDrivingModels.index_closest_to_point","text":"index_closest_to_point(curve::Curve, target::AbstractVec)\n\nreturns the curve index closest to the point described by target. target must be [x, y].\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.get_curve_index","page":"Roadways","title":"AutomotiveDrivingModels.get_curve_index","text":"get_curve_index(curve::Curve{T}, s::T) where T <: Real\n\nReturn the CurveIndex for the closest s-location on the curve\n\n\n\n\n\nget_curve_index(ind::CurveIndex, curve::Curve, Δs::T) where T <: Real\n\nReturn the CurveIndex at ind's s position + Δs\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Vec.lerp-Union{Tuple{T}, Tuple{VecE2{T},VecE2{T},VecE2{T},VecE2{T},T}} where T<:Real","page":"Roadways","title":"Vec.lerp","text":"cubic bezier lerp\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Vec.lerp-Union{Tuple{T}, Tuple{VecE2{T},VecE2{T},VecE2{T},T}} where T<:Real","page":"Roadways","title":"Vec.lerp","text":"quadratic bezier lerp\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#D-roadway-1","page":"Roadways","title":"1D roadway","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      StraightRoadway\n      mod_position_to_roadway\n      get_headway","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.StraightRoadway","page":"Roadways","title":"AutomotiveDrivingModels.StraightRoadway","text":"StraightRoadway\n\nA simple type representing a one lane, one dimensional straight roadway\n\nFields\n\nlength::Float64\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.mod_position_to_roadway","page":"Roadways","title":"AutomotiveDrivingModels.mod_position_to_roadway","text":"mod_position_to_roadway(s::Float64, roadway::StraightRoadway)\n\nperforms a modulo of the position s with the length of roadway\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.get_headway","page":"Roadways","title":"AutomotiveDrivingModels.get_headway","text":"get_headway(s_rear::Float64, s_fore::Float64, roadway::StraightRoadway)\n\nreturns a positive distance between srear and sfore.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Read-and-Write-roadways-1","page":"Roadways","title":"Read and Write roadways","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Base.read(io::IO, ::MIME\"text/plain\", ::Type{Roadway})\n      Base.write(io::IO, ::MIME\"text/plain\", roadway::Roadway)","category":"page"},{"location":"Roadways/#Base.read-Tuple{IO,MIME{Symbol(\"text/plain\")},Type{Roadway}}","page":"Roadways","title":"Base.read","text":"Base.read(io::IO, ::MIME\"text/plain\", ::Type{Roadway})\n\nextract roadway information from a text file and returns a roadway object.\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.write-Tuple{IO,MIME{Symbol(\"text/plain\")},Roadway}","page":"Roadways","title":"Base.write","text":"Base.write(io::IO, ::MIME\"text/plain\", roadway::Roadway)\n\nwrite all the roadway information to a text file\n\n\n\n\n\n","category":"method"},{"location":"collision_checkers/#Collision-Checker-1","page":"Collision Checker","title":"Collision Checker","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"There are two collisions checkers currently available in AutomotiveDrivingModels.jl.  The first collision checker is accessible through the function is_colliding and relies on Minkowski sum.  The second one is accessible through collision_checker and uses the parallel axis theorem. The latter is a bit faster.  A benchmark script is available in test/collision_checkers_benchmark.jl and relies on static arrays. ","category":"page"},{"location":"collision_checkers/#Parallel-Axis-Theorem-1","page":"Collision Checker","title":"Parallel Axis Theorem","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"This collision checker relies on the parallel axis theorem. It checks that two convex polygon overlap","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    collision_checker","category":"page"},{"location":"collision_checkers/#AutomotiveDrivingModels.collision_checker","page":"Collision Checker","title":"AutomotiveDrivingModels.collision_checker","text":"collision_checker(veh_a::Entity, veh_b::Entity)\ncollision_checker(veh_a, veh_b, veh_a_def::AbstractAgentDefinition, veh_b_def::AbstractAgentDefinition)\n\nreturn True if veh_a and veh_b collides. Relies on the parallel axis theorem.\n\n\n\n\n\ncollision_checker(scene::Frame{Entity{S,D,I}}, egoid::I) where {S, D<:AbstractAgentDefinition, I}\n\nreturn true if any entity in the scene collides with the entity of id egoid.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"Vehicles can be converted to polygon (static matrices containing four vertices).","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    polygon","category":"page"},{"location":"collision_checkers/#AutomotiveDrivingModels.polygon","page":"Collision Checker","title":"AutomotiveDrivingModels.polygon","text":"polygon(pos::VecSE2{Float64}, veh_def::AbstractAgentDefinition)\npolygon(x::Float64,y::Float64,theta::Float64, length::Float64, width::Float64)\n\nreturns a 4x2 static matrix corresponding to a rectangle around a car centered at pos and of dimensions specified by veh_def\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#Minkowski-Sum-1","page":"Collision Checker","title":"Minkowski Sum","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"Here are the methods available using Minkowski sum.","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    is_colliding\n    ConvexPolygon\n    CPAMemory\n    CollisionCheckResult\n    to_oriented_bounding_box!\n    get_oriented_bounding_box\n    is_potentially_colliding\n    get_collision_time\n    get_first_collision\n    is_collision_free\n    get_distance\n    get_edge","category":"page"},{"location":"collision_checkers/#AutomotiveDrivingModels.is_colliding","page":"Collision Checker","title":"AutomotiveDrivingModels.is_colliding","text":"is_colliding(ray::VecSE2{Float64}, poly::ConvexPolygon)\n\nreturns true if the ray collides with the polygon\n\n\n\n\n\nis_colliding(A::Entity{S,D,I}, B::Entity{S,D,I}, mem::CPAMemory=CPAMemory()) where {D<:AbstractAgentDefinition,I}\n\nreturns true if the vehicles A and B are colliding. It uses Minkowski sums.     is_colliding(mem::CPAMemory) returns true if vehA and vehB in mem collides.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.ConvexPolygon","page":"Collision Checker","title":"AutomotiveDrivingModels.ConvexPolygon","text":"ConvexPolygon\nConvexPolygon(npts::Int)\nConvexPolygon(pts::Vector{VecE2{Float64}})\n\nMutable structure to represent a convex polygon. It is used by the Minkowski sum collision checker\n\nFields\n\npts::Vector{VecE2{Float64}}\nnpts::Int\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveDrivingModels.CPAMemory","page":"Collision Checker","title":"AutomotiveDrivingModels.CPAMemory","text":"CPAMemory\n\nA structure to cache the bounding boxes around vehicle. It is part of the internals of the  Minkowski collision checker.\n\nFields\n\nvehA::ConvexPolygon bounding box for vehicle A\nvehB::ConvexPolygon bounding box for vehicle B\nmink::ConvexPolygon minkowski bounding box\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveDrivingModels.CollisionCheckResult","page":"Collision Checker","title":"AutomotiveDrivingModels.CollisionCheckResult","text":"CollisionCheckResult\n\nA type to store the result of a collision checker\n\nFields\n\nis_colliding::Bool\nA::Int64 # index of 1st vehicle\nB::Int64 # index of 2nd vehicle\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveDrivingModels.to_oriented_bounding_box!","page":"Collision Checker","title":"AutomotiveDrivingModels.to_oriented_bounding_box!","text":"to_oriented_bounding_box!(retval::ConvexPolygon, center::VecSE2{Float64}, len::Float64, wid::Float64)\nto_oriented_bounding_box!(retval::ConvexPolygon, veh::Entity{S,D,I}, center::VecSE2{Float64} = get_center(veh))\n\nFills in the vertices of retval according to the rectangle specification: center, length, width\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.get_oriented_bounding_box","page":"Collision Checker","title":"AutomotiveDrivingModels.get_oriented_bounding_box","text":"get_oriented_bounding_box(center::VecSE2{Float64}, len::Float64, wid::Float64) = to_oriented_bounding_box!(ConvexPolygon(4), center, len, wid)\nget_oriented_bounding_box(veh::Entity{S,D,I}, center::VecSE2{Float64} = get_center(veh))  where {S,D<:AbstractAgentDefinition,I}\n\nReturns a ConvexPolygon representing a bounding rectangle of the size specified by center, length, width\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.is_potentially_colliding","page":"Collision Checker","title":"AutomotiveDrivingModels.is_potentially_colliding","text":"is_potentially_colliding(A::Entity{S,D,I}, B::Entity{S,D,I}) where {S,D<:AbstractAgentDefinition,I}\n\nA fast collision check to remove things clearly not colliding\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.get_collision_time","page":"Collision Checker","title":"AutomotiveDrivingModels.get_collision_time","text":"get_collision_time(ray::VecSE2{Float64}, poly::ConvexPolygon, ray_speed::Float64)\n\nreturns the collision time between a ray and a polygon given ray_speed\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.get_first_collision","page":"Collision Checker","title":"AutomotiveDrivingModels.get_first_collision","text":"get_first_collision(scene::EntityFrame{S,D,I}, target_index::Int, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between a vehicle and scene[target_index]\n\n\n\n\n\nget_first_collision(scene::EntityFrame{S,D,I}, vehicle_indeces::AbstractVector{Int}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between any two vehicles in vehicle_indeces.\n\n\n\n\n\nget_first_collision(scene::EntityFrame{S,D,I}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between any two vehicles\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.is_collision_free","page":"Collision Checker","title":"AutomotiveDrivingModels.is_collision_free","text":"is_collision_free(scene::EntityFrame{S,D,I}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\nis_collision_free(scene::EntityFrame{S,D,I}, vehicle_indeces::AbstractVector{Int}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nCheck that there is no collisions between any two vehicles in scene\n\nIf vehicle_indeces is used, it only checks for vehicles within scene[vehicle_indeces]\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#Vec.get_distance","page":"Collision Checker","title":"Vec.get_distance","text":"Vec.get_distance(A::Entity{S,D,I}, B::Entity{S,D,I}, mem::CPAMemory=CPAMemory()) where {D<:AbstractAgentDefinition,I}\n\nreturns the euclidean distance between A and B.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.get_edge","page":"Collision Checker","title":"AutomotiveDrivingModels.get_edge","text":"get_edge(pts::Vector{VecE2{Float64}}, i::Int, npts::Int=length(pts))\n\nreturns the ith edge in pts\n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#Agent-Definition-1","page":"Agent Definition","title":"Agent Definition","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"Agent Definitions describe the static properties of a traffic participants such as the length and width of the vehicle. It also contains information on the type of agent (car, pedestrian, motorcycle...).","category":"page"},{"location":"agent_definitions/#Interface-1","page":"Agent Definition","title":"Interface","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"You can implement your own agent definition by creating a new type inheriting from the AbstractAgentDefinition type. The following three functions must be implemented for your custom type:","category":"page"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    AbstractAgentDefinition\n    length\n    width\n    class","category":"page"},{"location":"agent_definitions/#AutomotiveDrivingModels.AbstractAgentDefinition","page":"Agent Definition","title":"AutomotiveDrivingModels.AbstractAgentDefinition","text":"AbstractAgentDefinition\n\nAn Agent definition represents static parameters characterizing an agent,  such as its physical dimensions.\n\n\n\n\n\n","category":"type"},{"location":"agent_definitions/#Base.length","page":"Agent Definition","title":"Base.length","text":"length(def::AbstractAgentDefinition)\n\nreturn the length of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#AutomotiveDrivingModels.width","page":"Agent Definition","title":"AutomotiveDrivingModels.width","text":"width(def::AbstractAgentDefinition)\n\nreturn the width of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#AutomotiveDrivingModels.class","page":"Agent Definition","title":"AutomotiveDrivingModels.class","text":"class(def::AbstractAgentDefinition)\n\nreturn the class of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"Agent classes such as car, truck, and pedestrian are defined by integer constant in a submodule AgentClass.","category":"page"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    AgentClass","category":"page"},{"location":"agent_definitions/#AutomotiveDrivingModels.AgentClass","page":"Agent Definition","title":"AutomotiveDrivingModels.AgentClass","text":"A module to represent the different class of agents:\n\nMotorcycle\nCar\nTruck\nPedestrian\n\n\n\n\n\n","category":"module"},{"location":"agent_definitions/#Available-Agent-Definitions-1","page":"Agent Definition","title":"Available Agent Definitions","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    VehicleDef\n    BicycleModel","category":"page"},{"location":"agent_definitions/#AutomotiveDrivingModels.VehicleDef","page":"Agent Definition","title":"AutomotiveDrivingModels.VehicleDef","text":"VehicleDef(;class::Float64, length::Float64, width::Float64)\n\nVehicle definition which contains a class and a bounding box.\n\n\n\n\n\n","category":"type"},{"location":"agent_definitions/#AutomotiveDrivingModels.BicycleModel","page":"Agent Definition","title":"AutomotiveDrivingModels.BicycleModel","text":"BicycleModel\nBicycleModel(def::VehicleDef; a::Float64 = 1.5, b::Float64 = 1.5)\n\nVehicle definition representing the bicycle model\n\nFields\n\ndef::VehicleDef\na::Float64 distance between cg and front axle [m]\nb::Float64 distance between cg and rear axle [m]\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#Behaviors-1","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These stands one level above the actions. They provide a higher level decision that the actions then implement in order to propagate the simulation forward.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"A behavior model can be interpreted as a control law. Given the current scene, representing all  the vehicles present in the environment, a behavior model returns an action to execute. ","category":"page"},{"location":"behaviors/#Interface-1","page":"Behaviors","title":"Interface","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"We provide an interface to interact with behavior model or implement your own. To implement your own driver model you can create a type that inherits from the abstract type DriverModel. Then you can implement the following methods:","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    DriverModel{DriveAction}\n    get_name(::DriverModel)\n    action_type(::DriverModel{A}) where A\n    set_desired_speed!(model::DriverModel, v_des::Float64)\n    reset_hidden_state!(model::DriverModel)\n    observe!(model::DriverModel, scene::EntityFrame{S,D,I}, roadway, egoid::I) where {S,D,I}\n    Base.rand(model::DriverModel)","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.DriverModel","page":"Behaviors","title":"AutomotiveDrivingModels.DriverModel","text":"DriverModel{DriveAction}\n\nA DriverModel represents a specific driving behavior.  It specifies the action taken by the agent at a given scene. The ation will be of type DriveAction. It can be interpreted as a distribution, the likelihood of taking a certain action  in a given scene.  The DriverModel type is an abstract type! Custom driver models should inherit from it.\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#AutomotiveDrivingModels.action_type-Union{Tuple{DriverModel{A}}, Tuple{A}} where A","page":"Behaviors","title":"AutomotiveDrivingModels.action_type","text":"action_type(::DriverModel{A}) where {A}\n\nreturns the type of the actions that are sampled from the model\n\n\n\n\n\n","category":"method"},{"location":"behaviors/#Base.rand-Tuple{DriverModel}","page":"Behaviors","title":"Base.rand","text":"rand(model::DriverModel)\n\nSamples an action from the model.\n\n\n\n\n\n","category":"method"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"observe! and rand are usually the most important methods to implement. observe! sets the model state in a given situation and rand allows to sample an action from the model.","category":"page"},{"location":"behaviors/#Available-Behaviors-1","page":"Behaviors","title":"Available Behaviors","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    IntelligentDriverModel","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.IntelligentDriverModel","page":"Behaviors","title":"AutomotiveDrivingModels.IntelligentDriverModel","text":"IntelligentDriverModel <: LaneFollowingDriver\n\nThe Intelligent Driver Model. A rule based driving model that is governed by parameter settings. The output is an longitudinal acceleration.\n\nHere, we have extended IDM to the errorable IDM. If a standard deviation parameter is specified, then the output is a longitudinal acceleration sampled from a normal distribution around the non-errorable IDM output.\n\nFields\n\na::Float64 = NaN the predicted acceleration i.e. the output of the model\nσ::Float64 = NaN allows errorable IDM, optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk_spd::Float64 = 1.0 proportional constant for speed tracking when in freeflow [s⁻¹]\nδ::Float64 = 4.0 acceleration exponent\nT::Float64  = 1.5 desired time headway [s]\nv_des::Float64 = 29.0 desired speed [m/s]\ns_min::Float64 = 5.0 minimum acceptable gap [m]\na_max::Float64 = 3.0 maximum acceleration ability [m/s²]\nd_cmf::Float64 = 2.0 comfortable deceleration m/s²\nd_max::Float64 = 9.0 maximum deceleration m/s²\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    Tim2DDriver","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.Tim2DDriver","page":"Behaviors","title":"AutomotiveDrivingModels.Tim2DDriver","text":"Tim2DDriver\n\nDriver that combines longitudinal driver and lateral driver into one model.\n\nConstructors\n\nTim2DDriver(timestep::Float64;mlon::LaneFollowingDriver=IntelligentDriverModel(), mlat::LateralDriverModel=ProportionalLaneTracker(), mlane::LaneChangeModel=TimLaneChanger(timestep))\n\nFields\n\nmlon::LaneFollowingDriver = IntelligentDriverModel() Longitudinal driving model\nmlat::LateralDriverModel = ProportionalLaneTracker() Lateral driving model\nmlane::LaneChangeModel =TimLaneChanger Lane change model\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    PrincetonDriver","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.PrincetonDriver","page":"Behaviors","title":"AutomotiveDrivingModels.PrincetonDriver","text":"PrincetonDriver <: LaneFollowingDriver\n\nA lane following driver model that controls longitudinal speed by following a front car.\n\nFields\n\na::Float64\nσ::Float64 = NaN  optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk::Float64 = 1.0 proportional constant for speed tracking [s⁻¹]\nv_des::Float64 = 29.0  desired speed [m/s]\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    SidewalkPedestrianModel","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.SidewalkPedestrianModel","page":"Behaviors","title":"AutomotiveDrivingModels.SidewalkPedestrianModel","text":"SidewalkPedestrianModel\n\nWalks along the sidewalk until approaching the crosswalk. Waits for the cars to pass, then crosses.\n\nFields\n\ntimestep::Float64\nphase::Int = APPROACHING\nttc_threshold::Float64 = clamp(rand(Normal(4.0, 2.5)), 1.0, Inf)\ncrosswalk::Lane = Lane()\nsw_origin::Lane = Lane()\nsw_dest::Lane = Lane()\na::PedestrianLatLonAccel = PedestrianLatLonAccel(0.0, 0.0, sw_origin) makes you turn, left/right\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic\nv_des_approach::Float64 = clamp(rand(Normal(1.28, 0.18)), 0.0, Inf) Based on Feliciani et al. results\nv_des_appraise::Float64 = clamp(rand(Normal(0.94, 0.21)), 0.0, Inf)\nv_des_cross::Float64 = clamp(rand(Normal(1.35, 0.18)), 0.0, Inf)\nped_accel::Float64 = 0.30\nped_decel::Float64 = -0.50\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    StaticDriver","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.StaticDriver","page":"Behaviors","title":"AutomotiveDrivingModels.StaticDriver","text":"StaticDriver{A,P<:ContinuousMultivariateDistribution} <: DriverModel{A}\n\nA driver model where actions are always sampled by the same distribution specified  by the field distribution.\n\nFields\n\ndistribution::P\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#Lane-change-helper-functions-1","page":"Behaviors","title":"Lane change helper functions","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These are not standalone driver models but are used by the driver models to do lane changing and lateral control.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    MOBIL","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.MOBIL","page":"Behaviors","title":"AutomotiveDrivingModels.MOBIL","text":"MOBIL\n\nSee Treiber & Kesting, 'Modeling Lane-Changing Decisions with MOBIL'\n\nConstructor\n\nMOBIL(timestep::Float64;mlon::LaneFollowingDriver=IntelligentDriverModel(),safe_decel::Float64=2.0,       politeness::Float64=0.35,advantage_threshold::Float64=0.1)\n\nFields\n\ndir::Int\nmlon::LaneFollowingDriver=IntelligentDriverModel()\nsafe_decel::Float64=2.0\npoliteness::Float64=0.35\nadvantage_threshold::Float64=0.1\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    TimLaneChanger","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.TimLaneChanger","page":"Behaviors","title":"AutomotiveDrivingModels.TimLaneChanger","text":"TimLaneChanger\n\nA simple lane change behavior that changes lanes whenever the lead car is going slower than our desired speed. Lane changes are made when there is an available lane, fore/rear gaps exceed our thresholds, we are faster  than a rear vehicle in the target lane, and any lead vehicle in the target lane is faster than we can currently go.\n\nHas not been published anywhere, so first use in a paper would have to describe this. See MOBIL if you want a lane changer you can cite.\n\nConstructors\n\nTimLaneChanger(timestep::Float64;v_des::Float64=29.0,rec::SceneRecord=SceneRecord(2,timestep),threshold_fore::Float64 = 50.0,threshold_lane_change_gap_fore::Float64 = 10.0, threshold_lane_change_gap_rear::Float64 = 10.0,dir::Int=DIR_MIDDLE)\n\nFields\n\ndir::Int = DIR_MIDDLE the desired lane to go to eg: left,middle (i.e. stay in same lane) or right\nrec::SceneRecord TODO\nv_des::Float64 = 29.0 desired velocity\nthreshold_fore::Float64 = 50.0 Distance from lead vehicle\nthreshold_lane_change_gap_fore::Float64 = 10.0 Space in front\nthreshold_lane_change_gap_rear::Float64 = 10.0 Space rear\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    ProportionalLaneTracker","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.ProportionalLaneTracker","page":"Behaviors","title":"AutomotiveDrivingModels.ProportionalLaneTracker","text":"ProportionalLaneTracker\n\nA controller that executes the lane change decision made by the lane change models\n\nConstructors\n\nProportionalLaneTracker(;σ::Float64 = NaN,kp::Float64 = 3.0,kd::Float64 = 2.0)\n\nFields\n\na::Float64 = NaN predicted acceleration\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic behavior\nkp::Float64 = 3.0 proportional constant for lane tracking\nkd::Float64 = 2.0 derivative constant for lane tracking\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#Longitudinal-helper-functions-1","page":"Behaviors","title":"Longitudinal helper functions","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These are not standalone driver models but are used to do longitudinal control by the driver models.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    ProportionalSpeedTracker","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.ProportionalSpeedTracker","page":"Behaviors","title":"AutomotiveDrivingModels.ProportionalSpeedTracker","text":"ProportionalSpeedTracker <: LaneFollowingDriver\n\nLongitudinal proportional speed control.\n\nFields\n\na::Float64 = NaN  predicted acceleration\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk::Float64 = 1.0 proportional constant for speed tracking [s⁻¹]\nv_des::Float64 = 29.0  desired speed [m/s]\n\n\n\n\n\n","category":"type"},{"location":"actions/#Driving-Actions-1","page":"Driving Actions","title":"Driving Actions","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"In the driving stack, the actions lie one level below the behaviors. While the behaviors provide the high level decision making, the actions enable the execution of these decisions in the simulation.","category":"page"},{"location":"actions/#Interface-1","page":"Driving Actions","title":"Interface","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    propagate","category":"page"},{"location":"actions/#AutomotiveDrivingModels.propagate","page":"Driving Actions","title":"AutomotiveDrivingModels.propagate","text":"propagate(veh::Entity{S,D,I}, action::A, roadway::R, Δt::Float64) where {S,D,I,A,R}\n\nTake an entity of type {S,D,I} and move it over Δt seconds to produce a new entity based on the action on the given roadway.\n\n\n\n\n\nPropagate vehicle forward in time using a desired acceleration and turn rate\n\n\n\n\n\npropagate(veh::Entity{VehicleState,D,I}, action::AccelDesang, roadway::Roadway, Δt::Float64; n_integration_steps::Int=4) where {D,I}\n\nPropagate vehicle forward in time using a desired acceleration and heading angle\n\n\n\n\n\npropagate vehicle forward in time given a desired acceleration and steering angle. If steering angle higher than 0.1 radian, the vehicle drives in a circle\n\n\n\n\n\n","category":"function"},{"location":"actions/#Action-types-available-1","page":"Driving Actions","title":"Action types available","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelDesang","category":"page"},{"location":"actions/#AutomotiveDrivingModels.AccelDesang","page":"Driving Actions","title":"AutomotiveDrivingModels.AccelDesang","text":"AccelDesang\n\nAn action type with a longitudinal acceleration and a desired heading angle\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nϕdes::Float64 desired heading angle\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelSteeringAngle","category":"page"},{"location":"actions/#AutomotiveDrivingModels.AccelSteeringAngle","page":"Driving Actions","title":"AutomotiveDrivingModels.AccelSteeringAngle","text":"AccelSteeringAngle\n\nAllows driving the car in a circle based on the steering angle If steering angle less than threshold 0.01 radian, just drives straight\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nδ::Float64 Steering angle [rad]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelTurnrate","category":"page"},{"location":"actions/#AutomotiveDrivingModels.AccelTurnrate","page":"Driving Actions","title":"AutomotiveDrivingModels.AccelTurnrate","text":"AccelTurnrate\n\nAn action type with a longitudinal acceleration and a turn rate\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nω::Float64 desired turn rate [rad/sec]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    LaneFollowingAccel","category":"page"},{"location":"actions/#AutomotiveDrivingModels.LaneFollowingAccel","page":"Driving Actions","title":"AutomotiveDrivingModels.LaneFollowingAccel","text":"LaneFollowingAccel\n\nLongitudinal acceleration. The resulting vehicle velocity is capped below at 0 (i.e. standstill). Negative velocities are not allowed.\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    LatLonAccel","category":"page"},{"location":"actions/#AutomotiveDrivingModels.LatLonAccel","page":"Driving Actions","title":"AutomotiveDrivingModels.LatLonAccel","text":"LatLonAccel\n\nAcceleration in the frenet frame\n\nFields\n\na_lat::Float64 Lateral acceleration [m/s^2]\na_lon::Float64 Longitudinal acceleration [m/s^2]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    PedestrianLatLonAccel","category":"page"},{"location":"actions/#AutomotiveDrivingModels.PedestrianLatLonAccel","page":"Driving Actions","title":"AutomotiveDrivingModels.PedestrianLatLonAccel","text":"PedestrianLatLonAccel\n\nPedestrian walking action. Acceleration in the Frenet frame, along with desired lane after crossing the street.\n\nFields\n\na_lat::Float64 lateral acceleration [m/s^2]\na_lon::Float64 longitudinal accelaration [m/s^2]\nlane_des::Lane desired lane to move to\n\n\n\n\n\n","category":"type"},{"location":"states/#States-1","page":"States","title":"States","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"In this section of the documentation we explain the default vehicle state type provided by AutomotiveDrivingModels as well as the data types used to represent a driving scene. Most of the underlying structures are defined in Records.jl.  The data structures provided in ADM.jl are concrete instances of parametric types defined in Records. It is possible in principle to define your custom state definition and use the interface defined in ADM.jl.","category":"page"},{"location":"states/#Entity-state-1","page":"States","title":"Entity state","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"Entities are represented by the Entity data type provided by Records.jl (https://github.com/sisl/Records.jl/blob/master/src/entities.jl). The Entity data type has three fields: a state, a definition and an id. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"The state of an entity usually describes physical quantity such as position and velocity. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"Two state data structures are provided.","category":"page"},{"location":"states/#Defining-your-own-state-type-1","page":"States","title":"Defining your own state type","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"You can define your own state type if the provided VehicleState does not contain the right information. There are a of couple functions that need to be defined such that other functions in AutomotiveDrivingModels can work smoothly with your custom state type.","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    posg\n    posf\n    vel\n    velf\n    velg","category":"page"},{"location":"states/#AutomotiveDrivingModels.posg","page":"States","title":"AutomotiveDrivingModels.posg","text":"posg(state)\n\nreturns the coordinates of the state in the global (world) frame. The return type is expected to be a VecSE2.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.posf","page":"States","title":"AutomotiveDrivingModels.posf","text":"posf(state)\n\nreturns the coordinates of the state in the Frenet frame.  The return type is expected to be Frenet.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.vel","page":"States","title":"AutomotiveDrivingModels.vel","text":"vel(state)\n\nreturns the norm of the longitudinal velocity.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.velf","page":"States","title":"AutomotiveDrivingModels.velf","text":"velf(state)\n\nreturns the velocity of the state in the Frenet frame.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.velg","page":"States","title":"AutomotiveDrivingModels.velg","text":"velg(state)\n\nreturns the velocity of the state in the global (world) frame.\n\n\n\n\n\n","category":"function"},{"location":"states/#","page":"States","title":"States","text":"Example of a custom state type containing acceleration:","category":"page"},{"location":"states/#","page":"States","title":"States","text":"\n# you can use composition to define your custom state type based on existing ones\nstruct MyVehicleState\n    veh::VehicleState\n    acc::Float64\nend\n\n# define the functions from the interface \nposg(s::MyVehicleState) = posg(s.veh) # those functions are implemented for the `VehicleState` type\nposf(s::MyVehicleState) = posf(s.veh)\nvelg(s::MyVehicleState) = velg(s.veh)\nvelf(s::MyVehicleState) = velf(s.veh)\nvel(s::MyVehicleState) = vel(s.veh)","category":"page"},{"location":"states/#D-states-and-vehicles-1","page":"States","title":"1D states and vehicles","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"    State1D\n    Vehicle1D","category":"page"},{"location":"states/#AutomotiveDrivingModels.State1D","page":"States","title":"AutomotiveDrivingModels.State1D","text":"State1D\n\nA data type to represent one dimensional states\n\nFields\n\n- `s::Float64` position \n- `v::Float64` speed [m/s]\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveDrivingModels.Vehicle1D","page":"States","title":"AutomotiveDrivingModels.Vehicle1D","text":"Vehicle1D\n\nA specific instance of the Entity type defined in Records.jl to represent vehicles in 1d environments.\n\n\n\n\n\n","category":"type"},{"location":"states/#D-states-and-vehicles-2","page":"States","title":"2D states and vehicles","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"Here we list useful functions to interact with vehicle states and retrieve interesting information like the position of the front of the vehicle or the lane to which the vehicle belongs.","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    VehicleState\n    Vec.lerp(a::VehicleState, b::VehicleState, t::Float64, roadway::Roadway)\n    move_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64; ϕ₂::Float64=vehstate.posF.ϕ, ::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n    Vehicle\n    get_front\n    get_rear\n    get_center\n    get_footpoint\n    get_lane\n    Base.convert(::Type{Vehicle}, veh::Entity{VehicleState, D, Int64}) where D<:AbstractAgentDefinition","category":"page"},{"location":"states/#AutomotiveDrivingModels.VehicleState","page":"States","title":"AutomotiveDrivingModels.VehicleState","text":"VehicleState\n\nA default type to represent an agent physical state (position, velocity). It contains the position in the global frame, Frenet frame and the longitudinal velocity\n\nconstructors\n\nVehicleState(posG::VecSE2{Float64}, v::Float64) \nVehicleState(posG::VecSE2{Float64}, roadway::Roadway, v::Float64)\nVehicleState(posG::VecSE2{Float64}, lane::Lane, roadway::Roadway, v::Float64)\nVehicleState(posF::Frenet, roadway::Roadway, v::Float64)\n\nfields\n\nposG::VecSE2{Float64} global position\nposF::Frenet lane relative position\nv::Float64 longitudinal velocity\n\n\n\n\n\n","category":"type"},{"location":"states/#Vec.lerp-Tuple{VehicleState,VehicleState,Float64,Roadway}","page":"States","title":"Vec.lerp","text":"Vec.lerp(a::VehicleState, b::VehicleState, t::Float64, roadway::Roadway)\n\nPerform linear interpolation of the two vehicle states. Returns a VehicleState.\n\n\n\n\n\n","category":"method"},{"location":"states/#AutomotiveDrivingModels.move_along-Tuple{VehicleState,Roadway,Float64}","page":"States","title":"AutomotiveDrivingModels.move_along","text":"move_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64;\nϕ₂::Float64=vehstate.posF.ϕ, t₂::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n\nreturns a vehicle state after moving vehstate of a length Δs along its lane.\n\n\n\n\n\n","category":"method"},{"location":"states/#AutomotiveDrivingModels.Vehicle","page":"States","title":"AutomotiveDrivingModels.Vehicle","text":"Vehicle\n\nA specific instance of the Entity type defined in Records to represent Vehicles with  state VehicleState , definition VehicleDef and id Int64\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveDrivingModels.get_front","page":"States","title":"AutomotiveDrivingModels.get_front","text":"get_front(veh::Entity{VehicleState, VehicleDef, I})\n\nreturns the position of the front of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.get_rear","page":"States","title":"AutomotiveDrivingModels.get_rear","text":"get_rear(veh::Entity{VehicleState, VehicleDef, I})\n\nreturns the position of the rear of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.get_center","page":"States","title":"AutomotiveDrivingModels.get_center","text":"get_center(veh::Entity{VehicleState, D, I})\n\nreturns the position of the center of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.get_footpoint","page":"States","title":"AutomotiveDrivingModels.get_footpoint","text":"get_footpoint(veh::Entity{VehicleState, D, I})\n\nreturns the position of the footpoint of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.get_lane","page":"States","title":"AutomotiveDrivingModels.get_lane","text":"get_lane(roadway::Roadway, vehicle::Entity{S, D, I})\nget_lane(roadway::Roadway, vehicle::VehicleState)\n\nreturn the lane where vehicle is in.\n\n\n\n\n\n","category":"function"},{"location":"states/#Base.convert-Union{Tuple{D}, Tuple{Type{Entity{VehicleState,VehicleDef,Int64}},Entity{VehicleState,D,Int64}}} where D<:AbstractAgentDefinition","page":"States","title":"Base.convert","text":"Base.convert(::Type{Vehicle}, veh::Entity{VehicleState, D, Int64}) where D<:AbstractAgentDefinition\n\nConverts an entity in Vehicle (it is converting the agent definition only)\n\n\n\n\n\n","category":"method"},{"location":"states/#Scenes-1","page":"States","title":"Scenes","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"A Scene represents a collection of vehicles at a given time. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    Scene\n    SceneRecord\n    Trajdata","category":"page"},{"location":"states/#AutomotiveDrivingModels.Scene","page":"States","title":"AutomotiveDrivingModels.Scene","text":"Scene\n\nA Scene is a specific instance of the Frame type defined in Records. It represents a collection of vehicles at a given time.\n\nConstructors\n\n- `Scene(n::Int=100)`\n- `Scene(arr::Vector{Vehicle})`\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveDrivingModels.SceneRecord","page":"States","title":"AutomotiveDrivingModels.SceneRecord","text":"SceneRecord\n\nA SceneRecord is a specific instance of the QueueRecord type defined in Records.jl. It represents a collection of Scenes.\n\nconstructor\n\nSceneRecord(capacity::Int, timestep::Float64, frame_capacity::Int=100)\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveDrivingModels.Trajdata","page":"States","title":"AutomotiveDrivingModels.Trajdata","text":"Trajdata\n\nTrajdata is a specific instance of ListRecord defined in Records.jl. It is a collection of Scenes\n\n\n\n\n\n","category":"type"},{"location":"#About-1","page":"Home","title":"About","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is the documentation for AutomotiveDrivingModels.jl. ","category":"page"},{"location":"#Concepts-1","page":"Home","title":"Concepts","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This section defines a few terms that are used across the package.  See the specific section of the documentation for a more thorough explanation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Entity: An entity is a traffic participant that navigates in the environment, it is defined by a physical state (position, velocity, ...), an agent definition (whether it is a car or pedestrian, how large it is, ...), and an ID.\nScene: A scene represents a snapshot in time of a driving situation, it essentially consists of a list of entities at a given time.\nDriver Model: A driver model is a distribution over actions. Given a scene, each entity can update its model, we call this process observation (the corresponding method is observe!). After observing the scene, an action can be sampled from the driver model (using rand).\nActions: An action consists of a command applied to move the entity (e.g. longitudinal acceleration, steering). The state of the entity is updated using the propagate method which encodes the dynamics model.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package provides a default structure for representing entity states, entities, scenes, driver models and actions. However it has been designed to support custom types. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"AutomotiveDrivingModels is templated to efficiently run simulations with different types of entities. An entity represents an agent in the simulation, and it is parameterized by","category":"page"},{"location":"#","page":"Home","title":"Home","text":"S: state of the entity, may change over time\nD: definition of the entity, does not change over time\nI: unique identifier for the entity, typically an Int64 or Symbol","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In addition to the state, definition and identifier for each simulation agent, one can also customize the actions, environment and the driver models used by the agents.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Each section of the documentation contains an interface, which is a list of functions that a user must implement to use its own types.","category":"page"},{"location":"#Examples-1","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The following examples will showcase some of the simulation functionality of AutomotiveDrivingModels","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Driving on a Straight Roadway\nDriving in a Stadium\nIntersection\nCrosswalk\nSidewalk","category":"page"}]
}
