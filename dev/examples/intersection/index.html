<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Intersection · AutomotiveDrivingModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AutomotiveDrivingModels.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../straight_roadway/">Driving on a Straight Roadway</a></li><li><a class="tocitem" href="../stadium/">Driving in a Stadium</a></li><li class="is-active"><a class="tocitem" href>Intersection</a><ul class="internal"><li><a class="tocitem" href="#Generate-a-T-Shape-intersection-1"><span>Generate a T-Shape intersection</span></a></li><li><a class="tocitem" href="#Navigation-in-the-new-road-network-1"><span>Navigation in the new road network</span></a></li></ul></li><li><a class="tocitem" href="../crosswalk/">Crosswalk</a></li><li><a class="tocitem" href="../sidewalk/">Sidewalk</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../Roadways/">Roadways</a></li><li><a class="tocitem" href="../../actions/">Driving Actions</a></li><li><a class="tocitem" href="../../states/">States</a></li><li><a class="tocitem" href="../../agent_definitions/">Agent Definition</a></li><li><a class="tocitem" href="../../behaviors/">Behaviors</a></li><li><a class="tocitem" href="../../simulation/">Simulation</a></li><li><a class="tocitem" href="../../collision_checkers/">Collision Checker</a></li><li><a class="tocitem" href="../../feature_extraction/">Feature Extraction</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../Vec/">Vec</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Intersection</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Intersection</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sisl/AutomotiveDrivingModels.jl/blob/master/docs/src/examples/intersection.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Intersection-1"><a class="docs-heading-anchor" href="#Intersection-1">Intersection</a><a class="docs-heading-anchor-permalink" href="#Intersection-1" title="Permalink"></a></h1><p>In this example we demonstrate how to define a T-shape intersection with <code>AutomotiveDrivingModels</code>. You will also learn how to define your own custom action type and driver model type.</p><h2 id="Generate-a-T-Shape-intersection-1"><a class="docs-heading-anchor" href="#Generate-a-T-Shape-intersection-1">Generate a T-Shape intersection</a><a class="docs-heading-anchor-permalink" href="#Generate-a-T-Shape-intersection-1" title="Permalink"></a></h2><p>In order to generate the road network, we first initialize a Roadway object.</p><pre><code class="language-julia">using AutomotiveDrivingModels
using AutoViz
using Random

roadway = Roadway()</code></pre><p>Define coordinates of the entry and exit points to the intersection</p><pre><code class="language-julia">r = 5.0 # turn radius
w = DEFAULT_LANE_WIDTH

A = VecSE2(0.0,w,-π)
B = VecSE2(0.0,0.0,0.0)
C = VecSE2(r,-r,-π/2)
D = VecSE2(r+w,-r,π/2)
E = VecSE2(2r+w,0,0)
F = VecSE2(2r+w,w,-π)</code></pre><p>The next step consists in appending all the lanes to the road network. We can define a helper function to add a new lane to the roadway.</p><pre><code class="language-julia">function append_to_curve!(target::Curve, newstuff::Curve)
    s_end = target[end].s
    for c in newstuff
        push!(target, CurvePt(c.pos, c.s+s_end, c.k, c.kd))
    end
    return target
end</code></pre><p>Example of a lane that consists of 3 road segments, a straight curve (from the left to the center), a turning part (right turn) and a final  straight curve.</p><pre><code class="language-julia"># Append right turn coming from the left
curve = gen_straight_curve(convert(VecE2, B+VecE2(-100,0)), convert(VecE2, B), 2)
append_to_curve!(curve, gen_bezier_curve(B, C, 0.6r, 0.6r, 51)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, C), convert(VecE2, C+VecE2(0,-50.0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))

# visualize the current lane constellation
snapshot = render([roadway])</code></pre><p><img src="../partial_intersection.svg" alt="partial intersection"/></p><p>Let&#39;s repeat the process and complete the T-shape intersection</p><pre><code class="language-julia"># Append straight left
curve = gen_straight_curve(convert(VecE2, B+VecE2(-100,0)), convert(VecE2, B), 2)
append_to_curve!(curve, gen_straight_curve(convert(VecE2, B), convert(VecE2, E), 2)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, E), convert(VecE2, E+VecE2(50,0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))

# Append straight right
curve = gen_straight_curve(convert(VecE2, F+VecE2(50,0)), convert(VecE2, F), 2)
append_to_curve!(curve, gen_straight_curve(convert(VecE2, F), convert(VecE2, A), 2)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, A), convert(VecE2, A+VecE2(-100,0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))

# Append left turn coming from the right
curve = gen_straight_curve(convert(VecE2, F+VecE2(50,0)), convert(VecE2, F), 2)
append_to_curve!(curve, gen_bezier_curve(F, C, 0.9r, 0.9r, 51)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, C), convert(VecE2, C+VecE2(0,-50)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))

# Append right turn coming from below
curve = gen_straight_curve(convert(VecE2, D+VecE2(0,-50)), convert(VecE2, D), 2)
append_to_curve!(curve, gen_bezier_curve(D, E, 0.6r, 0.6r, 51)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, E), convert(VecE2, E+VecE2(50,0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))

# Append left turn coming from below
curve = gen_straight_curve(convert(VecE2, D+VecE2(0,-50)), convert(VecE2, D), 2)
append_to_curve!(curve, gen_bezier_curve(D, A, 0.9r, 0.9r, 51)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, A), convert(VecE2, A+VecE2(-100,0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))

snapshot = render([roadway])</code></pre><p><img src="../intersection.svg" alt="intersection"/></p><p>We can identify each lane thanks to the following user-defined functions. We define a <code>LaneOverlay</code> object that indicate the lane to highlight. One could implement any custom type to display other information on the lane. We then add a new method to the <code>add_renderable!</code> function that execute the specific action (coloring in blue). Look at <code>Autoviz.jl</code> for more detail on the function <code>add_renderable!</code>.</p><p>The following animation iterates over the individual lanes of the intersection layout and highlights them:</p><pre><code class="language-julia">struct LaneOverlay &lt;: SceneOverlay
    roadway::Roadway
    lane::Lane
    color::Colorant
end
function AutoViz.add_renderable!(rendermodel::RenderModel, overlay::LaneOverlay)
    add_renderable!(rendermodel, overlay.lane, overlay.roadway, color_asphalt=overlay.color)
end


using Reel

animation = roll(fps=1.0, duration=length(roadway.segments)) do t, dt
    i = Int(floor(t/dt)) + 1
    renderables = [
        roadway,
        LaneOverlay(roadway, roadway[LaneTag(i,1)], RGBA(0.0,0.0,1.0,0.5))
    ]
    render(renderables)
end;</code></pre><p><img src="../highlighted_lanes.gif" alt="highlighted lanes"/></p><h2 id="Navigation-in-the-new-road-network-1"><a class="docs-heading-anchor" href="#Navigation-in-the-new-road-network-1">Navigation in the new road network</a><a class="docs-heading-anchor-permalink" href="#Navigation-in-the-new-road-network-1" title="Permalink"></a></h2><p>Let&#39;s populate the intersection</p><pre><code class="language-julia">vs0 = VehicleState(B + polar(50.0,-π), roadway, 8.0) # initial state of the vehicle
scene = Scene([Vehicle(vs0, VehicleDef(), 1)])

snapshot = render([roadway, scene])</code></pre><p><img src="../intersection_populated.svg" alt="populated intersection"/></p><p>We will use lateral and longitudinal acceleration to control a car in the intersection. The first step is to define a corresponding action type that will contain the acceleration inputs.</p><pre><code class="language-julia">struct LaneSpecificAccelLatLon
    a_lat::Float64
    a_lon::Float64
end</code></pre><p>Next, add a method to the propagate function to update the state using our new action type. </p><pre><code class="language-julia">function AutomotiveDrivingModels.propagate(veh::Vehicle, action::LaneSpecificAccelLatLon, roadway::Roadway, Δt::Float64)
    lane_tag_orig = veh.state.posF.roadind.tag
    state = propagate(veh, LatLonAccel(action.a_lat, action.a_lon), roadway, Δt)
    roadproj = proj(state.posG, roadway[lane_tag_orig], roadway, move_along_curves=false)
    retval = VehicleState(Frenet(roadproj, roadway), roadway, state.v)
    return retval
end</code></pre><p><strong>Driver Model:</strong></p><p>We define a driver model, which can be seen as a distribution over actions.  # TODO Here we will define the simplest model, which is to repeat the same action.</p><pre><code class="language-julia">struct InterDriver &lt;: DriverModel{LaneSpecificAccelLatLon}
    a::LaneSpecificAccelLatLon
end

AutomotiveDrivingModels.observe!(model::InterDriver, scene::Scene, roadway::Roadway, egoid::Int64) = model
Base.rand(::AbstractRNG, model::InterDriver) = model.a</code></pre><p><strong>Simulate:</strong></p><p>First associate a model to each driver in the scene using a dictionary. Here we only have one driver identified by its ID: 1. Then everything is ready to run the <code>simulate!</code> function.</p><pre><code class="language-julia">using Reel

timestep = 0.1
nticks = 100

vs0 = VehicleState(B + polar(50.0,-π), roadway, 8.0)
scene = Scene([Vehicle(vs0, VehicleDef(), 1)])
models = Dict(1 =&gt; InterDriver(LaneSpecificAccelLatLon(0.0,0.0)))
scenes = simulate!(scene, roadway, models, nticks, timestep)

animation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt
    i = Int(floor(t/dt)) + 1
    renderables = [roadway, scenes[i]]
    render(renderables)
end</code></pre><pre><code class="language-none">&quot;animated_intersection.gif&quot;</code></pre><p><img src="../animated_intersection.gif" alt="animated intersection"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stadium/">« Driving in a Stadium</a><a class="docs-footer-nextpage" href="../crosswalk/">Crosswalk »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 20 March 2020 01:43">Friday 20 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
